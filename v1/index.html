<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Kubernetes Cluster Explorer</title>
    <style>
        :root {
            --master-node: #2E7D32;
            --master-core: #66BB6A;
            --worker-node: #455A64;
            --pipe: #00BCD4;
            --particle: #FFFFFF;
            --ui-bg: #263238;
            --ui-text: #ECEFF1;
            --ui-accent: #00BCD4;
            --ui-border: #37474F;
            --pod-running: #4CAF50;
            --pod-pending: #FFC107;
            --pod-failed: #F44336;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            background-color: #1a1a1a;
            color: var(--ui-text);
            overflow: hidden;
            display: flex;
        }

        #cluster-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        #cluster-container.navigate-tool {
            cursor: grab;
        }

        #cluster-container.navigate-tool:active {
            cursor: grabbing;
        }

        #cluster-container.select-tool {
            cursor: pointer;
        }

        .label {
            color: var(--ui-text);
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
        }

        .pod-label {
            font-size: 12px;
            padding: 2px 4px;
            background: rgba(0, 0, 0, 0.5);
        }

        .deployment-label {
            font-size: 14px;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
            border: 2px solid;
            background: rgba(0, 0, 0, 0.6);
        }

        .panel {
            background-color: var(--ui-bg);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            z-index: 10;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease-in-out;
        }

        #top-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 50px;
            background-color: var(--ui-bg);
            border-bottom: 2px solid var(--ui-border);
            display: flex;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            gap: 15px;
            z-index: 20;
        }

        #left-sidebar {
            position: fixed;
            top: 50px;
            left: 0;
            width: 320px;
            height: calc(100vh - 50px - 80px);
            padding: 20px;
            border-right: 2px solid var(--ui-border);
            overflow-y: auto;
        }

        #inspector-panel {
            position: fixed;
            top: 50px;
            right: 0;
            width: 350px;
            height: calc(100vh - 50px);
            padding: 20px;
            border-left: 2px solid var(--ui-border);
            transform: translateX(105%);
            z-index: 12;
            background: rgba(38, 50, 56, 0.95);
            backdrop-filter: blur(5px);
        }

        #inspector-panel.visible {
            transform: translateX(0);
        }

        #event-log {
            position: fixed;
            bottom: 0;
            left: 322px;
            width: calc(100% - 322px);
            height: 80px;
            background-color: rgba(38, 50, 56, 0.9);
            border-top: 2px solid var(--ui-border);
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
        }

        #hierarchy-panel {
            position: fixed;
            top: 50px;
            right: 0;
            width: 300px;
            height: calc(100vh - 50px);
            background: rgba(38, 50, 56, 0.85);
            backdrop-filter: blur(5px);
            border-left: 2px solid var(--ui-border);
            z-index: 15;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease-out;
        }

        #hierarchy-panel.collapsed {
            transform: translateX(calc(100% - 30px));
        }

        .panel-toggle-btn {
            position: absolute;
            top: 50%;
            left: 0;
            transform: translate(-100%, -50%);
            background: var(--ui-bg);
            border: 2px solid var(--ui-border);
            border-right: none;
            padding: 15px 5px;
            cursor: pointer;
            border-radius: 8px 0 0 8px;
        }

        #inspector-panel .panel-toggle-btn {
            display: none;
        }

        #hierarchy-header {
            padding: 10px;
            border-bottom: 1px solid var(--ui-border);
        }

        #hierarchy-search {
            width: calc(100% - 20px);
            padding: 8px;
            background: var(--ui-border);
            color: var(--ui-text);
            border: 1px solid var(--ui-accent);
            border-radius: 4px;
        }

        #hierarchy-tree {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            font-size: 14px;
        }

        #hierarchy-tree ul,
        #deployment-list ul {
            list-style-type: none;
            padding-left: 20px;
        }

        #hierarchy-tree li,
        #deployment-list li {
            margin: 4px 0;
        }

        .tree-item {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .tree-item:hover {
            background: rgba(0, 188, 212, 0.1);
        }

        .tree-swivel,
        .tree-eye {
            cursor: pointer;
            user-select: none;
        }

        .tree-swivel {
            width: 1em;
            display: inline-block;
        }

        .tree-item-children.collapsed {
            display: none;
        }

        .tree-item.hidden-by-search {
            display: none;
        }

        .tree-item .role {
            font-size: 12px;
            color: #90A4AE;
            margin-left: auto;
            padding-right: 5px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }

        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #modal-content {
            background: var(--ui-bg);
            padding: 20px;
            border-radius: 8px;
            border: 2px solid var(--ui-accent);
        }

        #modal-content input {
            width: 95%;
            margin-bottom: 15px;
            padding: 8px;
        }

        .gauge-container {
            width: 100%;
            height: 18px;
            background-color: #546E7A;
            border-radius: 9px;
            margin-top: 5px;
            overflow: hidden;
        }

        .gauge-bar {
            height: 100%;
            border-radius: 9px;
            transition: width 0.5s ease-out;
            text-align: right;
            padding-right: 5px;
            box-sizing: border-box;
            color: white;
            font-size: 11px;
            line-height: 18px;
        }

        .cpu-bar {
            background-color: #2196F3;
        }

        .mem-bar {
            background-color: var(--pod-running);
        }

        .tool-btn {
            font-size: 18px;
            padding: 5px 10px;
            background: var(--ui-border);
            color: var(--ui-text);
        }

        .tool-btn.active {
            background: var(--ui-accent);
            color: var(--ui-bg);
        }

        h2,
        h3 {
            color: var(--ui-accent);
            margin-top: 0;
            border-bottom: 1px solid var(--ui-border);
            padding-bottom: 10px
        }

        h3 .subtitle {
            font-size: 14px;
            color: var(--ui-text);
            font-weight: 400;
            display: block;
            margin-top: 4px
        }

        button {
            background-color: var(--ui-accent);
            color: var(--ui-bg);
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 700;
            transition: background-color .2s
        }

        button:hover {
            background-color: #00acc1
        }

        button.danger {
            background-color: #f44336;
            color: var(--ui-text)
        }

        select {
            width: 100%;
            padding: 8px;
            background-color: var(--ui-border);
            color: var(--ui-text);
            border: 1px solid var(--ui-accent);
            border-radius: 4px
        }

        .info-card {
            background-color: var(--ui-border);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-size: 14px
        }

        .info-card h4,
        .info-card h5 {
            margin: 0 0 10px;
            color: var(--ui-text)
        }

        .info-card p {
            margin: 5px 0
        }

        .info-card .explanation {
            font-style: italic;
            color: #b0bec5;
            font-size: 13px;
            margin-top: 10px;
            border-left: 3px solid var(--ui-accent);
            padding-left: 10px
        }

        #welcome-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 550px;
            background: rgba(38, 50, 56, .95);
            border: 2px solid var(--ui-accent);
            border-radius: 10px;
            padding: 30px;
            z-index: 1000;
            box-shadow: 0 0 25px rgba(0, 0, 0, .7)
        }
        
        code {
            background: rgba(0, 188, 212, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 13px;
        }
    </style>
</head>

<body>

    <div id="cluster-container"></div>
    <div id="welcome-panel">
        <h2>Welcome to the Kubernetes Explorer!</h2>
        <p>This is a live 3D simulation of a Kubernetes cluster with multi-plane architecture. Services float in the
            <b>Network Plane</b>, the Control Plane manages the cluster, and Worker Nodes run Pods in the <b>Data
                Plane</b>.</p>
        <p class="explanation"><b>Interaction Modes:</b><br>- Use the <b>Tool Palette</b> in the top bar to switch
            between navigating and selecting.<br>- üñêÔ∏è <b>Navigate:</b> Pan, zoom, and rotate the camera.<br>- üëÜ
            <b>Select:</b> Click objects to inspect them or drag-and-drop Pods.</p>
        <button id="close-welcome-btn">Let's Go!</button>
    </div>

    <div id="modal-overlay">
        <div id="modal-content">
            <h4>Name New Worker Node</h4> <input type="text" id="new-node-name-input"> <button
                id="confirm-add-node-btn">Create</button> <button id="cancel-add-node-btn">Cancel</button>
        </div>
    </div>
    <div id="top-bar">
        <button id="add-worker-btn">Add Worker Node</button>
        <button id="remove-worker-btn">Remove Worker Node</button>
        <button id="pause-btn">Pause</button>
        <div style="margin-left:auto; display:flex; gap: 5px;">
            <button id="select-tool" class="tool-btn" title="Select Tool (S)">üëÜ</button>
            <button id="navigate-tool" class="tool-btn active" title="Navigate Tool (V)">üñêÔ∏è</button>
        </div>
    </div>
    <div id="left-sidebar" class="panel">
        <div class="control-group">
            <h3>Cluster Overview</h3>
            <div class="info-card">
                <p>Nodes: <span id="node-count-str">1 Master, 1 Worker</span></p>
                <p>Total Pods: <span id="pod-count">0</span></p>
            </div>
        </div>
        <div class="control-group">
            <h3>Cluster Resource Pool</h3>
            <div class="info-card" id="resource-pool-stats"> <label>Aggregated CPU Usage:</label>
                <div class="gauge-container">
                    <div class="gauge-bar cpu-bar" id="total-cpu-gauge" style="width: 0%;"></div>
                </div><label>Aggregated Memory Usage:</label>
                <div class="gauge-container">
                    <div class="gauge-bar mem-bar" id="total-mem-gauge" style="width: 0%;"></div>
                </div>
            </div>
        </div>
        <div class="control-group">
            <h3>Create Deployment</h3>
            <div class="info-card"> <label for="image-select">Container Image:</label> <select id="image-select">
                    <option value="nginx" data-cpu="100" data-mem="128">nginx (small web server)</option>
                    <option value="redis" data-cpu="200" data-mem="256">redis (medium cache)</option>
                    <option value="postgres" data-cpu="500" data-mem="512">postgres (large database)</option>
                </select> <br><br> <label for="replica-slider">Replicas: <span id="replica-count-label">3</span></label>
                <input type="range" id="replica-slider" min="1" max="10" value="3">
                <p class="explanation">This tells the Deployment how many identical <b>Pods</b> (replicas) to keep
                    running.</p> <br> <button id="create-deployment-btn">Deploy</button>
            </div>
        </div>
        <div class="control-group">
            <h3>Active Deployments</h3>
            <div id="deployment-list" class="info-card" style="padding: 10px;"></div>
        </div>
        <div class="control-group">
            <h3>Create Service<span class="subtitle">(Network Layer)</span></h3>
            <div class="info-card"> 
                <label for="service-name-input">Service Name:</label>
                <input type="text" id="service-name-input" placeholder="my-service"
                    style="width: 100%; padding: 8px; background: var(--ui-border); color: var(--ui-text); border: 1px solid var(--ui-accent); border-radius: 4px; margin-bottom: 10px;">
                <label for="service-label-selector">Label Selector:</label> <select
                    id="service-label-selector" multiple
                    style="width: 100%; padding: 8px; background: var(--ui-border); color: var(--ui-text); border: 1px solid var(--ui-accent); border-radius: 4px; margin-bottom: 10px; min-height: 80px;">
                </select>
                <button id="create-service-btn">Create Service</button>
                <p class="explanation">Services use label selectors to find pods. Select one or more labels from the dropdown.<br>Hold Ctrl/Cmd to select multiple labels.</p>
            </div>
        </div>
        <div class="control-group">
            <h3>Active Services</h3>
            <div id="service-list"></div>
        </div>
    </div>

    <div id="inspector-panel" class="panel">
        <h3 id="inspector-title">Inspector</h3>
        <div id="inspector-content">
            <p>Click on any object in the cluster to see its details here.</p>
        </div> <button id="close-inspector-btn" style="position:absolute;top:10px;right:10px;">X</button>
    </div>
    <div id="hierarchy-panel"> <button id="toggle-hierarchy-btn" class="panel-toggle-btn">¬ª</button>
        <div id="hierarchy-header"> <input type="text" id="hierarchy-search" placeholder="Search..."> </div>
        <div id="hierarchy-tree"></div>
    </div>
    <div id="event-log">
        <p>[INFO] Control Plane online. Awaiting commands.</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            const CONFIG = {
                NODE_WIDTH_CPU_SCALE: 1 / 500, NODE_HEIGHT_MEM_SCALE: 1 / 1024 * 0.55, NODE_DEPTH_STORAGE: 8, POD_SCALE_FACTOR: 1 / 1024,
                APP_COLORS: { nginx: '#00ff88', redis: '#ff6347', postgres: '#4169e1', default: '#cccccc' },
                COLORS: { MASTER_NODE: 0x2E7D32, MASTER_CORE: 0x66BB6A, WORKER_NODE: 0x455A64, PIPE: 0x00BCD4, PARTICLE: 0xFFFFFF, POD_FAILED: 0xF44336, POD_PENDING: 0xFFC107, POD_RUNNING: 0x4CAF50 },
                PLANES: {
                    NETWORK: { y: 5, color: 0x00BCD4, label: 'Network Plane' },  // Reduced from 10 to 5
                    CONTROL: { y: 0.1, color: 0x2E7D32, label: 'Control Plane' },  // Slight offset to prevent z-fighting
                    DATA: { y: -5, color: 0x455A64, label: 'Data Plane' }
                }
            };

            const clusterState = { nodes: [], pods: {}, deployments: {}, services: {}, traffic: [], isPaused: false, nextId: 0, selectedServiceId: null };
            let scene, camera, renderer, controls, raycaster, mouse, labelRenderer, userIcon;
            const threeObjects = new Map();
            let draggedPod = null, originalPodState = {}, hasDragged = false, currentTool = 'navigate';

            function initThree() {
                const container = document.getElementById('cluster-container');
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a1a1a);
                scene.fog = new THREE.Fog(0x1a1a1a, 40, 100);
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 2000); camera.position.set(10, 15, 20);
                renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); container.appendChild(renderer.domElement);
                labelRenderer = new THREE.CSS2DRenderer(); labelRenderer.setSize(window.innerWidth, window.innerHeight); labelRenderer.domElement.style.position = 'absolute'; labelRenderer.domElement.style.top = '0px'; container.appendChild(labelRenderer.domElement);
                controls = new THREE.OrbitControls(camera, labelRenderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05; controls.minDistance = 1; controls.maxDistance = 100; controls.target.set(0, 2, -5);
                const ambient = new THREE.AmbientLight(0xffffff, 0.5); scene.add(ambient); const light = new THREE.DirectionalLight(0xffffff, 0.7); light.position.set(10, 20, 5); scene.add(light);
                raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();
                createUserIcon();
                createPlaneSeparators();
                window.addEventListener('resize', onWindowResize, false);
                labelRenderer.domElement.addEventListener('pointerdown', onPointerDown, false);
                labelRenderer.domElement.addEventListener('pointermove', onPointerMove, false);
                labelRenderer.domElement.addEventListener('pointerup', onPointerUp, false);
            }

            function getNextId() { return clusterState.nextId++; }
            function addNode(type, name) { if (clusterState.nodes.length >= 101) { logEvent('Cluster at maximum node capacity (100 workers).', 'WARN'); return; } const id = getNextId(); const node = { id, type, name: name || `${type}-node-${id}`, pods: new Set(), cpu: { usage: 0 }, memory: { usage: 0 }, isFailing: false, isVisible: true }; if (type === 'worker') { node.cpu.capacity = 4000; node.memory.capacity = 8192; } clusterState.nodes.push(node); createNodeVisual(node); logEvent(`${node.name} (${type}) is online.`); updateClusterOverview(); renderHierarchy(); }
            function removeLastWorkerNode() { const workers = clusterState.nodes.filter(n => n.type === 'worker'); if (workers.length === 0) { logEvent('No worker nodes to remove.', 'WARN'); return; } const nodeToRemove = workers[workers.length - 1]; failNode(nodeToRemove.id, true); setTimeout(() => { clusterState.nodes = clusterState.nodes.filter(n => n.id !== nodeToRemove.id); const mesh = threeObjects.get(nodeToRemove.id); if (mesh) { scene.remove(mesh); if (mesh.pipe) scene.remove(mesh.pipe); threeObjects.delete(nodeToRemove.id); const particlesToRemove = clusterState.traffic.filter(t => t.nodeId === nodeToRemove.id); particlesToRemove.forEach(p => scene.remove(p.mesh)); clusterState.traffic = clusterState.traffic.filter(t => t.nodeId !== nodeToRemove.id); } logEvent(`${nodeToRemove.name} fully decommissioned.`); updateClusterOverview(); repositionNodes(); renderHierarchy(); }, 3e3); }
            function createDeployment() { const option = document.getElementById('image-select').selectedOptions[0]; const depId = getNextId(); const newDep = { id: depId, name: `${option.value}-deployment-${depId}`, replicas: parseInt(document.getElementById('replica-slider').value, 10), image: option.value, cpuRequest: parseInt(option.dataset.cpu), memRequest: parseInt(option.dataset.mem), podIds: new Set(), isVisible: true }; clusterState.deployments[newDep.id] = newDep; logEvent(`Deployment '${newDep.name}' created. Goal: ${newDep.replicas} replicas.`); updateDeploymentList(); renderHierarchy(); }
            function createService() {
                const nameInput = document.getElementById('service-name-input');
                const serviceName = nameInput.value.trim();
                
                const select = document.getElementById('service-label-selector');
                const selectedOptions = Array.from(select.selectedOptions);
                if (selectedOptions.length === 0) {
                    logEvent('Please select at least one label from the dropdown', 'WARN');
                    return;
                }
                
                const selector = {};
                selectedOptions.forEach(option => {
                    const [key, value] = option.value.split('=');
                    if (key && value) selector[key] = value;
                });

                const srvId = getNextId();
                const newSrv = {
                    id: srvId,
                    name: serviceName || `service-${srvId}`,  // Use custom name or default
                    selector: selector,
                    isVisible: true,
                    networkLines: []
                };
                clusterState.services[srvId] = newSrv;
                createServiceVisual(newSrv);
                const selectorStr = Object.entries(selector).map(([k, v]) => `${k}=${v}`).join(', ');
                logEvent(`Service '${newSrv.name}' created with selector: ${selectorStr}`);
                updateServiceList();
                renderHierarchy();
                nameInput.value = '';  // Clear the input for next service
            }
            function scaleDeployment(id, reps) { const deployment = clusterState.deployments[id]; if (!deployment) return; logEvent(`Scaling '${deployment.name}' from ${deployment.replicas} to ${reps} replicas.`); deployment.replicas = reps; updateDeploymentList(); }
            function terminatePod(podId, reason) { const pod = clusterState.pods[podId]; if (!pod || pod.status === 'Terminating') return; pod.status = 'Terminating'; const podMesh = threeObjects.get(podId); if (podMesh) new TWEEN.Tween(podMesh.scale).to({ x: 0, y: 0, z: 0 }, 500).onComplete(() => { podMesh.parent?.remove(podMesh); threeObjects.delete(podId); recalculateServicePositions(); }).start(); if (pod.nodeId) { const node = clusterState.nodes.find(n => n.id === pod.nodeId); if (node) { node.pods.delete(podId); recalculateNodeResources(node); } } const dep = clusterState.deployments[pod.deploymentId]; if (dep) dep.podIds.delete(podId); logEvent(`Pod ${pod.name} was ${reason}.`); setTimeout(() => { delete clusterState.pods[podId]; renderHierarchy(); updateDeploymentList(); updateLabelSelector(); }, 500); }
            function failNode(nodeId, isRemoval = false) { const node = clusterState.nodes.find(n => n.id === nodeId); if (!node || node.type === 'master') return; node.isFailing = true; const nodeMesh = threeObjects.get(nodeId); if (nodeMesh) nodeMesh.material.color.set(CONFIG.COLORS.POD_FAILED); logEvent(`Worker Node ${node.name} is failing! Evacuating pods...`, 'ERROR'); Array.from(node.pods).forEach(podId => { const pod = clusterState.pods[podId]; if (!pod) return; pod.status = 'Pending'; pod.nodeId = null; const podMesh = threeObjects.get(podId); if (podMesh) { const worldPos = new THREE.Vector3(); podMesh.getWorldPosition(worldPos); scene.attach(podMesh); podMesh.position.copy(worldPos); podMesh.material.color.set(CONFIG.COLORS.POD_PENDING); } }); node.pods.clear(); recalculateNodeResources(node); renderHierarchy(); if (isRemoval) return; setTimeout(() => { node.isFailing = false; if (nodeMesh) nodeMesh.material.color.set(CONFIG.COLORS.WORKER_NODE); logEvent(`Worker Node ${node.name} has recovered.`); updateResourcePoolView(); }, 1e4); }
            function killPod(podId) { const pod = clusterState.pods[podId]; if (!pod) return; pod.status = 'Failed'; const podMesh = threeObjects.get(podId); if (podMesh) podMesh.material.color.set(CONFIG.COLORS.POD_FAILED); logEvent(`Pod ${pod.name} killed! Control Plane will replace it.`, 'WARN'); setTimeout(() => { if (clusterState.pods[podId]?.status === 'Failed') terminatePod(podId, "cleaned up"); }, 2e3); }
            function findSchedulableNode(cpu, mem) { return clusterState.nodes.find(n => n.type === 'worker' && !n.isFailing && (n.cpu.usage + cpu <= n.cpu.capacity) && (n.memory.usage + mem <= n.memory.capacity)); }
            function simulateTraffic(serviceId) {
                const srv = clusterState.services[serviceId]; if (!srv) return; const portalMesh = threeObjects.get(`srv-${srv.id}`);
                // Find pods that match the service's label selector
                const matchingPods = Object.values(clusterState.pods).filter(pod => {
                    if (!pod.labels || !srv.selector) return false;
                    return Object.entries(srv.selector).every(([key, value]) => pod.labels[key] === value);
                });
                const podMeshes = matchingPods.map(pod => threeObjects.get(pod.id)).filter(Boolean);
                if (podMeshes.length === 0) return;
                for (let i = 0; i < 10; i++) { const particle = new THREE.Mesh(new THREE.SphereGeometry(.2, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffffff })); const targetPod = podMeshes[Math.floor(Math.random() * podMeshes.length)]; const podPos = new THREE.Vector3(); targetPod.getWorldPosition(podPos); const path = new THREE.CatmullRomCurve3([userIcon.position, portalMesh.position, podPos]); particle.position.copy(userIcon.position); scene.add(particle); new TWEEN.Tween({ t: 0 }).to({ t: 1 }, 1500 + Math.random() * 500).easing(TWEEN.Easing.Quadratic.InOut).onUpdate(({ t }) => { path.getPointAt(t, particle.position); }).onComplete(() => { scene.remove(particle); }).delay(i * 100).start(); }
            }
            function createUserIcon() { const loader = new THREE.TextureLoader(); loader.load('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0id2hpdGUiPjxwYXRoIGQ9Ik0xMiAyQzYuNDggMiAyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBTMTcuNTIgMiAxMiAyem0wIDNjMS42NiAwIDMgMS4zNCAzIDNzLTEuMzQgMy0zIDMtMy0xLjM0LTMtMyAxLjM0LTMgMy0zem0wIDE0LjJjLTIuNSAwLTQuNzEtMS4yOC02LTIuMjIuMDMtMS45OSA0LTMuMDggNi0zLjA4czUuOTcgMS4wOSA2IDMuMDhjLTEuMjkgLjk0LTMuNSAyLjIyLTYgMi4yMnoiLz48L3N2Zz4=', texture => { const mat = new THREE.SpriteMaterial({ map: texture }); userIcon = new THREE.Sprite(mat); userIcon.position.set(20, 10, 0); userIcon.scale.set(2, 2, 2); scene.add(userIcon); }) }
            function createPlaneSeparators() {
                const planeSize = 100;
                Object.entries(CONFIG.PLANES).forEach(([key, plane]) => {
                    // Create semi-transparent plane
                    const planeGeom = new THREE.PlaneGeometry(planeSize, planeSize);
                    const planeMat = new THREE.MeshBasicMaterial({
                        color: plane.color,
                        transparent: true,
                        opacity: 0.05,
                        side: THREE.DoubleSide
                    });
                    const planeMesh = new THREE.Mesh(planeGeom, planeMat);
                    planeMesh.rotation.x = -Math.PI / 2;
                    planeMesh.position.y = plane.y;
                    planeMesh.userData = { type: 'plane', name: key };
                    planeMesh.frustumCulled = false;
                    scene.add(planeMesh);
                    threeObjects.set(`plane-${key}`, planeMesh);

                    // Add plane label
                    const label = createHtmlLabel(plane.label, new THREE.Vector3(25, plane.y, 0));
                    label.element.style.fontSize = '18px';
                    label.element.style.fontWeight = 'bold';
                    label.element.style.color = '#' + plane.color.toString(16).padStart(6, '0');
                    scene.add(label);
                });
            }
            function createHtmlLabel(text, pos) { const div = document.createElement('div'); div.className = 'label'; div.textContent = text; const label = new THREE.CSS2DObject(div); label.position.copy(pos); return label; }

            function reconciliationLoop() { if (clusterState.isPaused) return; let stateChanged = false; Object.values(clusterState.deployments).forEach(dep => { const currentPods = Array.from(dep.podIds).map(id => clusterState.pods[id]).filter(p => p && p.status !== 'Terminating'); if (currentPods.length > dep.replicas) { const podToKill = currentPods[0]; if (podToKill) { terminatePod(podToKill.id, "scaled down"); stateChanged = true; } } else if (currentPods.length < dep.replicas) { const id = getNextId(); clusterState.pods[id] = { id, deploymentId: dep.id, name: `${dep.image}-pod-${id}`, image: dep.image, status: 'Pending', nodeId: null, cpuRequest: dep.cpuRequest, memRequest: dep.memRequest, isVisible: true, labels: { app: dep.image, deployment: dep.name } }; dep.podIds.add(id); logEvent(`Pod for ${dep.name} is Pending.`); stateChanged = true; } }); Object.values(clusterState.pods).filter(p => p.status === 'Pending').forEach(pod => { const node = findSchedulableNode(pod.cpuRequest, pod.memRequest); if (node) { pod.status = 'Running'; pod.nodeId = node.id; node.pods.add(pod.id); recalculateNodeResources(node); createPodVisual(pod, node); logEvent(`Pod ${pod.name} scheduled on Node ${node.name}.`); stateChanged = true; } else { logEvent(`No available Node has enough resources for pod ${pod.name}.`, 'WARN') } }); if (stateChanged) { renderHierarchy(); updateDeploymentList(); updateLabelSelector(); } updateDeploymentVisuals(); updateServiceVisuals(); updateClusterOverview(); updateResourcePoolView(); }
            function createNodeVisual(node) {
                let mesh; if (node.type === 'master') {
                    const group = new THREE.Group(); const foundationGeom = new THREE.BoxGeometry(1, 1, 1); const foundationMat = new THREE.MeshLambertMaterial({ color: CONFIG.COLORS.MASTER_NODE, transparent: true, opacity: .6 }); const foundationMesh = new THREE.Mesh(foundationGeom, foundationMat); foundationMesh.position.y = -.5; foundationMesh.frustumCulled = false; foundationMesh.renderOrder = -2; const coreMat = new THREE.MeshLambertMaterial({ color: CONFIG.COLORS.MASTER_CORE }); node.coreMesh = new THREE.Mesh(new THREE.SphereGeometry(.5, 16, 16), coreMat); node.coreMesh.position.y = 0; group.add(foundationMesh, node.coreMesh);
                    // Add control plane component orbs
                    const components = [
                        { name: 'API Server', angle: 0, color: 0x4CAF50 },
                        { name: 'etcd', angle: Math.PI / 2, color: 0x2196F3 },
                        { name: 'Scheduler', angle: Math.PI, color: 0xFFC107 },
                        { name: 'Controller Manager', angle: 3 * Math.PI / 2, color: 0xFF5722 }
                    ];
                    node.componentOrbs = [];
                    components.forEach(comp => {
                        const orbGeom = new THREE.SphereGeometry(0.2, 12, 12);
                        const orbMat = new THREE.MeshLambertMaterial({
                            color: comp.color,
                            emissive: comp.color,
                            emissiveIntensity: 0.3
                        });
                        const orb = new THREE.Mesh(orbGeom, orbMat);
                        orb.userData = { component: comp.name, baseAngle: comp.angle };
                        const radius = 1.5;
                        orb.position.set(
                            Math.cos(comp.angle) * radius,
                            0.3,
                            Math.sin(comp.angle) * radius
                        );
                        const label = createHtmlLabel(comp.name, new THREE.Vector3(0, 0.3, 0));
                        label.element.style.fontSize = '10px';
                        label.element.style.padding = '2px 6px';
                        orb.add(label);
                        group.add(orb);
                        node.componentOrbs.push(orb);
                    });
                    mesh = group; mesh.frustumCulled = false; mesh.add(createHtmlLabel("Control Plane", new THREE.Vector3(0, 1.5, 0)));
                } else { const width = node.cpu.capacity * CONFIG.NODE_WIDTH_CPU_SCALE; const height = node.memory.capacity * CONFIG.NODE_HEIGHT_MEM_SCALE; const depth = CONFIG.NODE_DEPTH_STORAGE; const mat = new THREE.MeshLambertMaterial({ color: CONFIG.COLORS.WORKER_NODE, transparent: true, opacity: .3, side: THREE.DoubleSide }); mesh = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), mat); mesh.position.y = height / 2; mesh.frustumCulled = false; mesh.renderOrder = -1; mesh.add(createHtmlLabel(node.name, new THREE.Vector3(0, height / 2 + .5, 0))); } mesh.userData = { id: node.id, type: 'node' }; scene.add(mesh); threeObjects.set(node.id, mesh); repositionNodes(); if (node.type === 'worker') createPipe(node);
            }
            function createPodVisual(pod, node) { const nodeMesh = threeObjects.get(node.id); if (!nodeMesh) return; const podSize = .5 + (pod.cpuRequest + pod.memRequest) * CONFIG.POD_SCALE_FACTOR; const mat = new THREE.MeshLambertMaterial({ color: new THREE.Color(CONFIG.APP_COLORS[pod.image] || CONFIG.APP_COLORS.default) }); const podMesh = new THREE.Mesh(new THREE.CylinderGeometry(podSize / 2, podSize / 2, podSize, 6), mat); const nodeBoxSize = new THREE.Vector3(); new THREE.Box3().setFromObject(nodeMesh).getSize(nodeBoxSize); const podSpacing = podSize * 1.2; const podsPerRow = Math.floor(nodeBoxSize.x / podSpacing); const podIndexOnNode = Array.from(node.pods).indexOf(pod.id); const col = podIndexOnNode % podsPerRow; const row = Math.floor(podIndexOnNode / podsPerRow); podMesh.position.set(-nodeBoxSize.x / 2 + (col * podSpacing) + podSpacing / 2, -nodeBoxSize.y / 2 + podSize / 2, -nodeBoxSize.z / 2 + (row * podSpacing) + podSpacing / 2); podMesh.userData = { id: pod.id, type: 'pod' }; podMesh.scale.set(.01, .01, .01); const label = createHtmlLabel(pod.image, new THREE.Vector3(0, podSize / 2 + .2, 0)); label.element.classList.add('pod-label'); podMesh.add(label); nodeMesh.add(podMesh); threeObjects.set(pod.id, podMesh); new TWEEN.Tween(podMesh.scale).to({ x: 1, y: 1, z: 1 }, 500).easing(TWEEN.Easing.Elastic.Out).start(); recalculateServicePositions(); }
            function createServiceVisual(srv) {
                // Find the first matching pod to determine color
                const matchingPod = Object.values(clusterState.pods).find(pod => {
                    if (!pod.labels || !srv.selector) return false;
                    return Object.entries(srv.selector).every(([key, value]) => pod.labels[key] === value);
                });
                const color = matchingPod ?
                    new THREE.Color(CONFIG.APP_COLORS[matchingPod.image] || CONFIG.APP_COLORS.default) :
                    new THREE.Color(CONFIG.COLORS.PIPE); // Default color if no pods match

                const portalGeom = new THREE.TorusGeometry(1.5, .2, 16, 100); const portalMat = new THREE.MeshBasicMaterial({ color, side: THREE.DoubleSide }); const portalMesh = new THREE.Mesh(portalGeom, portalMat); portalMesh.rotation.x = Math.PI / 2; portalMesh.userData = { id: srv.id, type: 'service' }; const label = createHtmlLabel(srv.name, new THREE.Vector3(0, 0.5, 0)); portalMesh.add(label); portalMesh.label = label; scene.add(portalMesh); threeObjects.set(`srv-${srv.id}`, portalMesh); recalculateServicePosition(srv);
            }
            function createPipe(workerNode) { const masterNode = clusterState.nodes.find(n => n.type === 'master'); const masterMesh = threeObjects.get(masterNode.id); const workerMesh = threeObjects.get(workerNode.id); if (!masterMesh || !workerMesh) return; const startPoint = workerMesh.position.clone().setY(0); const endPoint = workerMesh.position.clone().setY(workerMesh.geometry.parameters.height / -2); const path = new THREE.LineCurve3(startPoint, endPoint); const pipeGeom = new THREE.TubeGeometry(path, 20, .1, 8, false); const pipeMat = new THREE.MeshBasicMaterial({ color: CONFIG.COLORS.PIPE }); const pipeMesh = new THREE.Mesh(pipeGeom, pipeMat); workerMesh.pipe = pipeMesh; scene.add(pipeMesh); for (let i = 0; i < 3; i++) { const particle = new THREE.Mesh(new THREE.SphereGeometry(.15, 8, 8), new THREE.MeshBasicMaterial({ color: CONFIG.COLORS.PARTICLE })); clusterState.traffic.push({ mesh: particle, path, progress: i * .33, nodeId: workerNode.id }); scene.add(particle); } }
            function repositionNodes() { const workers = clusterState.nodes.filter(n => n.type === 'worker'); const master = clusterState.nodes.find(n => n.type === 'master'); if (master) threeObjects.get(master.id).position.set(0, 0, 0); const boundingBox = new THREE.Box3(); workers.forEach((node, i) => { const mesh = threeObjects.get(node.id); if (mesh) { mesh.position.set((i % 2 === 0 ? -1 : 1) * 7, mesh.position.y, -8 + (Math.floor(i / 2) * -12)); boundingBox.expandByObject(mesh); if (mesh.pipe) { const startPoint = mesh.position.clone().setY(0); const endPoint = mesh.position.clone().setY(mesh.geometry.parameters.height / -2); const newPath = new THREE.LineCurve3(startPoint, endPoint); mesh.pipe.geometry.dispose(); mesh.pipe.geometry = new THREE.TubeGeometry(newPath, 20, .1, 8, false); clusterState.traffic.filter(t => t.nodeId === node.id).forEach(t => t.path = newPath); } } }); const masterMeshGroup = threeObjects.get(master.id); if (masterMeshGroup) { const foundationMesh = masterMeshGroup.children[0]; if (workers.length > 0) { const size = new THREE.Vector3(); boundingBox.getSize(size); const center = new THREE.Vector3(); boundingBox.getCenter(center); foundationMesh.scale.set(size.x + 10, 1, size.z + 10); foundationMesh.position.set(center.x, -.5, center.z); } else { foundationMesh.scale.set(1, 1, 1); foundationMesh.position.set(0, -.5, 0); } } recalculateServicePositions(); }
            function updateDeploymentVisuals() { Object.values(clusterState.deployments).forEach(dep => { let depBoxVisual = threeObjects.get(`dep-${dep.id}`); const podMeshes = Array.from(dep.podIds).map(id => clusterState.pods[id] && threeObjects.get(id)).filter(Boolean); if (podMeshes.length === 0) { if (depBoxVisual) { scene.remove(depBoxVisual.label); scene.remove(depBoxVisual); threeObjects.delete(`dep-${dep.id}`); } return; } const boundingBox = new THREE.Box3(); podMeshes.forEach(podMesh => boundingBox.expandByObject(podMesh)); if (!depBoxVisual) { const colorHex = CONFIG.APP_COLORS[dep.image] || CONFIG.APP_COLORS.default; const boxMat = new THREE.MeshLambertMaterial({ color: new THREE.Color(colorHex), transparent: true, opacity: .1, emissive: new THREE.Color(colorHex), emissiveIntensity: 0, side: THREE.DoubleSide }); depBoxVisual = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), boxMat); depBoxVisual.userData = { id: dep.id, type: 'deployment' }; depBoxVisual.frustumCulled = false; const label = createHtmlLabel(dep.name, new THREE.Vector3()); label.element.classList.add('deployment-label'); label.element.style.color = colorHex; label.element.style.borderColor = colorHex; depBoxVisual.label = label; scene.add(depBoxVisual); scene.add(label); threeObjects.set(`dep-${dep.id}`, depBoxVisual); } const size = new THREE.Vector3(); boundingBox.getSize(size); const center = new THREE.Vector3(); boundingBox.getCenter(center); if (size.x > 0) { depBoxVisual.scale.copy(size).addScalar(1.5); depBoxVisual.position.copy(center); depBoxVisual.label.position.set(center.x, boundingBox.max.y + 1, center.z); depBoxVisual.visible = dep.isVisible; depBoxVisual.label.visible = dep.isVisible; } }); }
            function updateServiceVisuals() {
                Object.values(clusterState.services).forEach(srv => {
                    const portalMesh = threeObjects.get(`srv-${srv.id}`); if (!portalMesh) return;
                    // Find pods that match the service's label selector
                    const matchingPods = Object.values(clusterState.pods).filter(pod => {
                        if (!pod.labels || !srv.selector) return false;
                        return Object.entries(srv.selector).every(([key, value]) => pod.labels[key] === value);
                    });

                    const podMeshes = matchingPods.map(pod => threeObjects.get(pod.id)).filter(Boolean);

                    // Always show service, even if no pods match
                    portalMesh.visible = srv.isVisible;
                    if (portalMesh.label) portalMesh.label.visible = srv.isVisible;

                    // Update network lines
                    srv.networkLines.forEach(line => scene.remove(line));
                    srv.networkLines = [];

                    podMeshes.forEach(podMesh => {
                        const podPos = new THREE.Vector3();
                        podMesh.getWorldPosition(podPos);
                        const points = [portalMesh.position, podPos];
                        const lineGeom = new THREE.BufferGeometry().setFromPoints(points);
                        const lineMat = new THREE.LineBasicMaterial({
                            color: portalMesh.material.color,
                            transparent: true,
                            opacity: 0.3,
                            linewidth: 2
                        });
                        const line = new THREE.Line(lineGeom, lineMat);
                        line.visible = srv.isVisible;
                        srv.networkLines.push(line);
                        scene.add(line);
                    });
                });
            }
            function recalculateServicePosition(srv) {
                const portalMesh = threeObjects.get(`srv-${srv.id}`); if (!portalMesh || !srv.isVisible) return;
                // Position service in the Network Plane
                const networkPlaneY = CONFIG.PLANES.NETWORK.y;

                // Find pods that match the service's label selector
                const matchingPods = Object.values(clusterState.pods).filter(pod => {
                    if (!pod.labels || !srv.selector) return false;
                    return Object.entries(srv.selector).every(([key, value]) => pod.labels[key] === value);
                });

                if (matchingPods.length === 0) {
                    // Default position if no matching pods
                    portalMesh.position.set(0, networkPlaneY, -5);
                    return;
                }

                // Calculate center position of matching pods
                let centerX = 0, centerZ = 0;
                matchingPods.forEach(pod => {
                    const podMesh = threeObjects.get(pod.id);
                    if (podMesh) {
                        const worldPos = new THREE.Vector3();
                        podMesh.getWorldPosition(worldPos);
                        centerX += worldPos.x;
                        centerZ += worldPos.z;
                    }
                });
                centerX /= matchingPods.length;
                centerZ /= matchingPods.length;

                portalMesh.position.set(centerX, networkPlaneY, centerZ);
                
                // Check for overlaps with other services and adjust if needed
                const serviceRadius = 2; // Minimum distance between services
                Object.values(clusterState.services).forEach(otherSrv => {
                    if (otherSrv.id === srv.id) return;
                    const otherMesh = threeObjects.get(`srv-${otherSrv.id}`);
                    if (!otherMesh) return;
                    
                    const distance = portalMesh.position.distanceTo(otherMesh.position);
                    if (distance < serviceRadius) {
                        // Offset this service to avoid overlap
                        const offset = new THREE.Vector3()
                            .subVectors(portalMesh.position, otherMesh.position)
                            .normalize()
                            .multiplyScalar(serviceRadius);
                        portalMesh.position.add(offset);
                    }
                });
            }
            function recalculateServicePositions() { Object.values(clusterState.services).forEach(recalculateServicePosition); }
            function animate() {
                requestAnimationFrame(animate); if (clusterState.isPaused) return; const time = Date.now() * 0.001; const masterNode = clusterState.nodes.find(n => n.type === 'master'); if (masterNode?.coreMesh) {
                    masterNode.coreMesh.material.emissive.setHex(CONFIG.COLORS.MASTER_CORE); masterNode.coreMesh.material.emissiveIntensity = Math.sin(time * 3) * .4 + .6;
                    // Animate component orbs
                    if (masterNode.componentOrbs) {
                        masterNode.componentOrbs.forEach(orb => {
                            const angle = orb.userData.baseAngle + time * 0.5;
                            const radius = 1.5;
                            orb.position.set(
                                Math.cos(angle) * radius,
                                0.3 + Math.sin(time * 2 + orb.userData.baseAngle) * 0.1,
                                Math.sin(angle) * radius
                            );
                            orb.material.emissiveIntensity = 0.3 + Math.sin(time * 4 + orb.userData.baseAngle) * 0.2;
                        });
                    }
                } clusterState.traffic.forEach(p => { p.progress = (p.progress + 0.005) % 1; p.path.getPointAt(p.progress, p.mesh.position); }); if (clusterState.selectedServiceId) { const srv = clusterState.services[clusterState.selectedServiceId]; if (srv) { const portalMesh = threeObjects.get(`srv-${srv.id}`); if (portalMesh) { portalMesh.material.emissive = new THREE.Color(portalMesh.material.color); portalMesh.material.emissiveIntensity = Math.sin(time * 5) * .3 + .3; } } } TWEEN.update(); controls.update(); renderer.render(scene, camera); labelRenderer.render(scene, camera);
            }
            function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); labelRenderer.setSize(window.innerWidth, window.innerHeight); }
            function onPointerDown(event) { if (event.button !== 0 || currentTool !== 'select') return; hasDragged = false; const intersects = getIntersects(event); if (intersects.length > 0) { const obj = intersects.find(i => i.object.userData.type === 'pod')?.object; if (obj) { draggedPod = obj; originalPodState = { position: draggedPod.position.clone(), parent: draggedPod.parent }; controls.enabled = false; } } }
            function onPointerMove(event) { if (!draggedPod) return; if (!hasDragged) { hasDragged = true; document.body.style.cursor = 'grabbing'; const worldPos = new THREE.Vector3(); draggedPod.getWorldPosition(worldPos); scene.attach(draggedPod); draggedPod.position.copy(worldPos); } const intersects = getIntersects(event); const planeIntersect = intersects.find(i => i.object.userData.type === 'node'); if (planeIntersect) draggedPod.position.set(planeIntersect.point.x, draggedPod.position.y, planeIntersect.point.z); else { const pos = new THREE.Vector3(); raycaster.ray.at(10, pos); draggedPod.position.copy(pos); } }
            function onPointerUp(event) { if (currentTool !== 'select') return; if (draggedPod) { if (hasDragged) { const intersects = getIntersects(event); const dropTarget = intersects.find(i => i.object.userData.type === 'node' && i.object.userData.id !== originalPodState.parent.userData.id)?.object; if (dropTarget) { const pod = clusterState.pods[draggedPod.userData.id]; const targetNode = clusterState.nodes.find(n => n.id === dropTarget.userData.id); if (targetNode.cpu.usage + pod.cpuRequest <= targetNode.cpu.capacity && targetNode.memory.usage + pod.memRequest <= targetNode.memory.capacity) { const oldNode = clusterState.nodes.find(n => n.id === pod.nodeId); oldNode.pods.delete(pod.id); recalculateNodeResources(oldNode); pod.nodeId = targetNode.id; targetNode.pods.add(pod.id); recalculateNodeResources(targetNode); dropTarget.add(draggedPod); repositionPodInNode(draggedPod, targetNode); logEvent(`Pod ${pod.name} moved to Node ${targetNode.name}.`); } else { logEvent(`Node ${targetNode.name} lacks resources for Pod ${pod.name}.`, 'WARN'); originalPodState.parent.add(draggedPod); repositionPodInNode(draggedPod, originalPodState.parent); } } else { originalPodState.parent.add(draggedPod); draggedPod.position.copy(originalPodState.position); } renderHierarchy(); updateDeploymentList(); draggedPod = null; controls.enabled = true; return; } else if (!hasDragged) { draggedPod = null; controls.enabled = true; } } const intersects = getIntersects(event); Object.values(clusterState.deployments).forEach(d => { const box = threeObjects.get(`dep-${d.id}`); if (box) box.material.emissiveIntensity = 0; }); clusterState.selectedServiceId = null; if (intersects.length > 0) { let obj = intersects.find(i => i.object.userData.id)?.object; if (obj) { if (obj.parent?.userData.type === 'node') obj = obj.parent; } if (obj?.userData.id) { const { id, type } = obj.userData; if (type === 'node') showNodeInspector(id); if (type === 'pod') showPodInspector(id); if (type === 'deployment') showDeploymentInspector(id); if (type === 'service') { showServiceInspector(id); clusterState.selectedServiceId = id; } } } else { hideInspector(); } }
            function getIntersects(event) { const canvasBounds = renderer.domElement.getBoundingClientRect(); mouse.x = ((event.clientX - canvasBounds.left) / canvasBounds.width) * 2 - 1; mouse.y = -((event.clientY - canvasBounds.top) / canvasBounds.height) * 2 + 1; raycaster.setFromCamera(mouse, camera); return raycaster.intersectObjects(scene.children, true); }
            function repositionPodInNode(podMesh, nodeMesh) { const pod = clusterState.pods[podMesh.userData.id]; const node = clusterState.nodes.find(n => n.id === nodeMesh.userData.id); const podSize = .5 + (pod.cpuRequest + pod.memRequest) * CONFIG.POD_SCALE_FACTOR; const nodeBoxSize = new THREE.Vector3(); new THREE.Box3().setFromObject(nodeMesh).getSize(nodeBoxSize); const podSpacing = podSize * 1.2; const podsPerRow = Math.floor(nodeBoxSize.x / podSpacing); const podIndexOnNode = Array.from(node.pods).indexOf(pod.id); const col = podIndexOnNode % podsPerRow; const row = Math.floor(podIndexOnNode / podsPerRow); const newPos = new THREE.Vector3(-nodeBoxSize.x / 2 + (col * podSpacing) + podSpacing / 2, -nodeBoxSize.y / 2 + podSize / 2, -nodeBoxSize.z / 2 + (row * podSpacing) + podSpacing / 2); new TWEEN.Tween(podMesh.position).to(newPos, 300).easing(TWEEN.Easing.Quadratic.Out).start(); }
            function recalculateNodeResources(node) { node.cpu.usage = 0; node.memory.usage = 0; node.pods.forEach(id => { const p = clusterState.pods[id]; if (p) { node.cpu.usage += p.cpuRequest; node.memory.usage += p.memRequest; } }); }
            function logEvent(message, level = 'INFO') { const logEl = document.getElementById('event-log'); const p = document.createElement('p'); const time = new Date().toLocaleTimeString(); p.textContent = `[${time}] [${level}] ${message}`; if (level === 'WARN') p.style.color = CONFIG.COLORS.POD_PENDING; if (level === 'ERROR') p.style.color = CONFIG.COLORS.POD_FAILED; logEl.prepend(p); if (logEl.children.length > 50) logEl.removeChild(logEl.lastChild); }
            function updateClusterOverview() { const workers = clusterState.nodes.filter(n => n.type === 'worker').length; document.getElementById('node-count-str').textContent = `1 Master, ${workers} Worker${workers !== 1 ? 's' : ''}`; document.getElementById('pod-count').textContent = Object.keys(clusterState.pods).filter(k => clusterState.pods[k].status !== 'Terminating').length; }
            function updateResourcePoolView() { const workers = clusterState.nodes.filter(n => n.type === 'worker' && !n.isFailing); let totalCpu = 0, totalMem = 0, usedCpu = 0, usedMem = 0; workers.forEach(n => { totalCpu += n.cpu.capacity; totalMem += n.memory.capacity; usedCpu += n.cpu.usage; usedMem += n.memory.usage; }); const cpuPercent = totalCpu > 0 ? (usedCpu / totalCpu * 100).toFixed(1) : 0; const memPercent = totalMem > 0 ? (usedMem / totalMem * 100).toFixed(1) : 0; document.getElementById('total-cpu-gauge').style.width = `${cpuPercent}%`; document.getElementById('total-cpu-gauge').textContent = `${usedCpu}m / ${totalCpu}m (${cpuPercent}%)`; document.getElementById('total-mem-gauge').style.width = `${memPercent}%`; document.getElementById('total-mem-gauge').textContent = `${usedMem}Mi / ${totalMem}Mi (${memPercent}%)`; }
            function updateDeploymentList() { const listEl = document.getElementById('deployment-list'); listEl.innerHTML = '<ul></ul>'; const ul = listEl.querySelector('ul'); Object.values(clusterState.deployments).forEach(dep => { const running = Array.from(dep.podIds).filter(id => clusterState.pods[id]?.status === 'Running').length; const el = document.createElement('li'); el.innerHTML = `<div class="tree-item" data-id="${dep.id}" data-type="deployment"><span class="tree-swivel">‚ñ∂</span><span style="color:${CONFIG.APP_COLORS[dep.image]}">${dep.name} (${running}/${dep.replicas})</span></div>`; const podsUl = document.createElement('ul'); podsUl.className = 'tree-item-children collapsed'; Array.from(dep.podIds).map(id => clusterState.pods[id]).filter(Boolean).forEach(pod => { const podLi = document.createElement('li'); const statusColor = { Running: CONFIG.COLORS.POD_RUNNING, Pending: CONFIG.COLORS.POD_PENDING, Failed: CONFIG.COLORS.POD_FAILED, Terminating: '#aaa' }[pod.status]; podLi.innerHTML = `<div class="tree-item" data-id="${pod.id}" data-type="pod"><span class="status-dot" style="background-color:${statusColor};"></span><span>${pod.name} on ${clusterState.nodes.find(n => n.id === pod.nodeId)?.name || 'N/A'}</span></div>`; podsUl.appendChild(podLi); }); el.appendChild(podsUl); ul.appendChild(el); }); }
            function showNodeInspector(nodeId) { const node = clusterState.nodes.find(n => n.id === nodeId); if (!node) return; hideHierarchy(); document.getElementById('inspector-panel').classList.add('visible'); document.getElementById('inspector-title').textContent = `Node: ${node.name}`; let content = ''; if (node.type === 'master') { content = `<div class="info-card"><h5>What is this?</h5><p class="explanation">A <b>Master Node</b> runs the <b>Control Plane</b> components (the orbiting spheres) which manage the entire cluster:<br>‚Ä¢ <b>API Server</b> (green) - Entry point for all operations<br>‚Ä¢ <b>etcd</b> (blue) - Distributed key-value store<br>‚Ä¢ <b>Scheduler</b> (yellow) - Assigns pods to nodes<br>‚Ä¢ <b>Controller Manager</b> (orange) - Maintains desired state</p></div>`; } else { const cpuUsage = ((node.cpu.usage / node.cpu.capacity) * 100).toFixed(1); const memUsage = ((node.memory.usage / node.memory.capacity) * 100).toFixed(1); content = `<div class="info-card"><h5>What is this?</h5><p class="explanation">A <b>Worker Node</b> IS a machine (virtual or physical) that runs your application Pods. It contributes its CPU and Memory to the cluster-wide <b>Resource Pool</b> shown on the left.</p></div><div class="info-card"><h4>Node Capacity & Usage</h4><p>CPU: ${node.cpu.usage}m / ${node.cpu.capacity}m (${cpuUsage}%)</p><p>Memory: ${node.memory.usage}Mi / ${node.memory.capacity}Mi (${memUsage}%)</p><p>Pods Running: ${node.pods.size}</p><br><button class="danger" onclick="window.sim.failNode(${node.id})">Simulate Node Failure</button></div>`; } document.getElementById('inspector-content').innerHTML = content; }
            function showPodInspector(podId) { const pod = clusterState.pods[podId]; if (!pod) return; hideHierarchy(); document.getElementById('inspector-panel').classList.add('visible'); document.getElementById('inspector-title').textContent = `Pod: ${pod.name}`; 
                const labelsStr = pod.labels ? Object.entries(pod.labels).map(([k, v]) => `${k}=${v}`).join(', ') : 'None';
                document.getElementById('inspector-content').innerHTML = `<div class="info-card"><h5>What is this?</h5><p class="explanation">A <b>Pod</b> is a wrapper around one or more application <b>Containers</b>. The Container (which holds your app code) runs inside the Pod. The Pod is the smallest 'physical' unit that can be scheduled to run on a Node.</p></div><div class="info-card"><h4>Pod Details</h4><p>Based on Image: ${pod.image}</p><p>Status: ${pod.status}</p><p>Running on: Node ${clusterState.nodes.find(n => n.id === pod.nodeId)?.name || 'N/A'}</p><p>Labels: <code>${labelsStr}</code></p><h5>Resource Requests</h5><p>CPU: ${pod.cpuRequest}m | Memory: ${pod.memRequest}Mi</p><br><button class="danger" onclick="window.sim.killPod(${pod.id})">Kill Pod</button></div>`; }
            function showDeploymentInspector(depId) { const dep = clusterState.deployments[depId]; if (!dep) return; hideHierarchy(); document.getElementById('inspector-panel').classList.add('visible'); document.getElementById('inspector-title').textContent = `Deployment: ${dep.name}`; document.getElementById('inspector-content').innerHTML = `<div class="info-card"><h5>What is this?</h5><p class="explanation">A <b>Deployment</b> manages the Pods for <b>one component</b> of your application (e.g., the web servers). A complete 'Application' is often composed of multiple Deployments and Services working together. <br><br><b>This visual box is a LOGICAL grouping, not a physical one.</b></p></div><div class="info-card"><h4>Deployment Status</h4><p>Desired Replicas: ${dep.replicas}</p><p>Current Pods: ${Array.from(dep.podIds).filter(id => clusterState.pods[id]).length}</p><p>Container Image: ${dep.image}</p></div>`; }
            function showServiceInspector(srvId) { const srv = clusterState.services[srvId]; if (!srv) return; hideHierarchy(); document.getElementById('inspector-panel').classList.add('visible'); document.getElementById('inspector-title').textContent = `Service: ${srv.name}`; document.getElementById('inspector-content').innerHTML = `<div class="info-card"><h5>What is this?</h5><p class="explanation">A <b>Service</b> operates in the <b>Network Plane</b> above the cluster. It uses <b>label selectors</b> to find matching pods and provides a stable network endpoint for accessing them. Services are managed by the Control Plane but exist independently of any specific node.</p></div><div class="info-card"><h4>Service Details</h4><p>Label Selector: ${srv.selector ? Object.entries(srv.selector).map(([k, v]) => `${k}=${v}`).join(', ') : 'None'}</p><p>Matching Pods: ${Object.values(clusterState.pods).filter(pod => pod.labels && srv.selector && Object.entries(srv.selector).every(([key, value]) => pod.labels[key] === value)).length}</p></div>`; }
            function hideInspector() { document.getElementById('inspector-panel').classList.remove('visible'); showHierarchy(); }
            function hideHierarchy() { document.getElementById('hierarchy-panel').style.display = 'none'; }
            function showHierarchy() { document.getElementById('hierarchy-panel').style.display = 'flex'; }
            function updateServiceList() { const listEl = document.getElementById('service-list'); listEl.innerHTML = ''; Object.values(clusterState.services).forEach(srv => { const el = document.createElement('div'); el.className = 'info-card'; const selectorStr = srv.selector ? Object.entries(srv.selector).map(([k, v]) => `${k}=${v}`).join(', ') : 'None'; el.innerHTML = `<h4>${srv.name}</h4><p>Selector: ${selectorStr}</p><button onclick="window.sim.simulateTraffic(${srv.id})">Simulate Traffic</button>`; listEl.appendChild(el); }); }
            function updateLabelSelector() {
                const select = document.getElementById('service-label-selector');
                const currentSelections = Array.from(select.selectedOptions).map(opt => opt.value);
                
                // Collect all unique labels from all pods
                const labelSet = new Set();
                Object.values(clusterState.pods).forEach(pod => {
                    if (pod.labels && pod.status !== 'Terminating') {
                        Object.entries(pod.labels).forEach(([key, value]) => {
                            labelSet.add(`${key}=${value}`);
                        });
                    }
                });
                
                // Clear and repopulate the select
                select.innerHTML = '';
                
                if (labelSet.size === 0) {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'No pod labels available';
                    option.disabled = true;
                    select.appendChild(option);
                } else {
                    // Sort labels and add them as options
                    Array.from(labelSet).sort().forEach(label => {
                        const option = document.createElement('option');
                        option.value = label;
                        option.textContent = label;
                        // Restore previous selections
                        if (currentSelections.includes(label)) {
                            option.selected = true;
                        }
                        select.appendChild(option);
                    });
                }
            }
            function renderHierarchy() { const treeContainer = document.getElementById('hierarchy-tree'); const scrollTop = treeContainer.scrollTop; treeContainer.innerHTML = ''; const clusterUl = document.createElement('ul'); clusterUl.innerHTML = `<li><div class="tree-item"><span class="tree-swivel">‚ñº</span><span><b>Cluster</b></span></div></li>`; const clusterLi = clusterUl.firstElementChild; const resourcesUl = document.createElement('ul'); resourcesUl.className = 'tree-item-children'; const nodesLi = document.createElement('li'); nodesLi.innerHTML = `<div class="tree-item"><span class="tree-swivel">‚ñº</span><span><b>Nodes</b></span></div>`; const nodesUl = document.createElement('ul'); nodesUl.className = 'tree-item-children'; clusterState.nodes.forEach(node => { const nodeLi = document.createElement('li'); const eyeIcon = node.isVisible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è'; nodeLi.innerHTML = `<div class="tree-item" data-id="${node.id}" data-type="node"><span class="tree-swivel">${node.pods.size > 0 ? '‚ñ∂' : ''}</span><span class="tree-eye">${eyeIcon}</span><span>${node.name}</span><span class="role">(${node.type})</span></div>`; const podsUl = document.createElement('ul'); podsUl.className = 'tree-item-children collapsed'; Array.from(node.pods).map(id => clusterState.pods[id]).filter(Boolean).forEach(pod => { const podLi = document.createElement('li'); const podEye = pod.isVisible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è'; podLi.innerHTML = `<div class="tree-item" data-id="${pod.id}" data-type="pod"><span class="tree-swivel">‚ñº</span><span class="tree-eye">${podEye}</span><span style="color:${CONFIG.APP_COLORS[pod.image]}">Pod: ${pod.name}</span></div>`; const containerUl = document.createElement('ul'); containerUl.className = 'tree-item-children'; containerUl.innerHTML = `<li><div class="tree-item"><span class="tree-swivel"></span><span class="tree-eye" style="opacity:0.5"></span><span style="color:${CONFIG.APP_COLORS[pod.image]}">Container: ${pod.image}</span></div></li>`; podLi.appendChild(containerUl); podsUl.appendChild(podLi); }); if (node.pods.size > 0) nodeLi.appendChild(podsUl); nodesUl.appendChild(nodeLi); }); nodesLi.appendChild(nodesUl); resourcesUl.appendChild(nodesLi); const depsLi = document.createElement('li'); depsLi.innerHTML = `<div class="tree-item"><span class="tree-swivel">‚ñº</span><span><b>Deployments</b></span></div>`; const depsUl = document.createElement('ul'); depsUl.className = 'tree-item-children'; Object.values(clusterState.deployments).forEach(dep => { const depLi = document.createElement('li'); const eyeIcon = dep.isVisible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è'; depLi.innerHTML = `<div class="tree-item" data-id="${dep.id}" data-type="deployment"><span class="tree-swivel"></span><span class="tree-eye">${eyeIcon}</span><span style="color: ${CONFIG.APP_COLORS[dep.image]}">${dep.name}</span></div>`; depsUl.appendChild(depLi); }); depsLi.appendChild(depsUl); resourcesUl.appendChild(depsLi); const srvsLi = document.createElement('li'); srvsLi.innerHTML = `<div class="tree-item"><span class="tree-swivel">‚ñº</span><span><b>Services</b></span></div>`; const srvsUl = document.createElement('ul'); srvsUl.className = 'tree-item-children'; Object.values(clusterState.services).forEach(srv => { const srvLi = document.createElement('li'); const eyeIcon = srv.isVisible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è'; const matchingPod = Object.values(clusterState.pods).find(pod => { if (!pod.labels || !srv.selector) return false; return Object.entries(srv.selector).every(([key, value]) => pod.labels[key] === value); }); const color = matchingPod ? CONFIG.APP_COLORS[matchingPod.image] : '#00BCD4'; srvLi.innerHTML = `<div class="tree-item" data-id="${srv.id}" data-type="service"><span class="tree-swivel"></span><span class="tree-eye">${eyeIcon}</span><span style="color: ${color}">${srv.name}</span></div>`; srvsUl.appendChild(srvLi); }); srvsLi.appendChild(srvsUl); resourcesUl.appendChild(srvsLi); clusterLi.appendChild(resourcesUl); treeContainer.appendChild(clusterUl); treeContainer.scrollTop = scrollTop; }
            function toggleTreeItemVisibility(element, isVisible) {
                const { id, type } = element.dataset; let stateObject; let threeObj; if (type === 'node') stateObject = clusterState.nodes.find(n => n.id == id); if (type === 'pod') stateObject = clusterState.pods[id]; if (type === 'deployment') stateObject = clusterState.deployments[id]; if (type === 'service') stateObject = clusterState.services[id]; if (stateObject) {
                    stateObject.isVisible = isVisible; element.querySelector('.tree-eye').textContent = isVisible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è'; if (type === 'deployment') threeObj = threeObjects.get(`dep-${id}`); else if (type === 'service') threeObj = threeObjects.get(`srv-${id}`); else threeObj = threeObjects.get(stateObject.id); if (threeObj) {
                        threeObj.visible = isVisible; 
                        threeObj.traverse(child => { 
                            if (child.isCSS2DObject) child.visible = isVisible; 
                        }); 
                        if (type === 'deployment') {
                            // Services are now independent of deployments
                        }
                        if (type === 'node') {
                            const node = stateObject;
                            node.pods.forEach(podId => {
                                const pod = clusterState.pods[podId];
                                if (pod) {
                                    pod.isVisible = isVisible;
                                    const podEye = document.querySelector(`.tree-item[data-id="${pod.id}"]`);
                                    if (podEye) toggleTreeItemVisibility(podEye, isVisible);
                                }
                            });
                        }
                        if (type === 'service') {
                            const srv = stateObject;
                            srv.networkLines.forEach(line => line.visible = isVisible);
                        }
                    }
                }
            }
                            function showAddNodeModal() { const modal = document.getElementById('modal-overlay'); const input = document.getElementById('new-node-name-input'); const workerCount = clusterState.nodes.filter(n => n.type === 'worker').length; input.value = `worker-node-${workerCount + 1}`; modal.style.display = 'flex'; input.focus(); }
                            function hideAddNodeModal() { document.getElementById('modal-overlay').style.display = 'none'; }
                            function setTool(toolName) {
                                currentTool = toolName;
                                document.getElementById('cluster-container').className = `${toolName}-tool`;
                                document.getElementById('select-tool').classList.toggle('active', toolName === 'select');
                                document.getElementById('navigate-tool').classList.toggle('active', toolName === 'navigate');
                                controls.enabled = toolName === 'navigate';
                            }

                            document.getElementById('hierarchy-tree').addEventListener('click', e => { const item = e.target.closest('.tree-item'); if (!item) return; if (e.target.classList.contains('tree-swivel')) { const children = item.nextElementSibling; if (children) { children.classList.toggle('collapsed'); e.target.textContent = children.classList.contains('collapsed') ? '‚ñ∂' : '‚ñº'; } } else if (e.target.classList.contains('tree-eye')) { const currentVisibility = e.target.textContent === 'üëÅÔ∏è'; toggleTreeItemVisibility(item, !currentVisibility); } else { const { id, type } = item.dataset; if (type === 'node') showNodeInspector(id); if (type === 'pod') showPodInspector(id); if (type === 'deployment') showDeploymentInspector(id); if (type === 'service') { showServiceInspector(id); clusterState.selectedServiceId = id; } } });
                            document.getElementById('hierarchy-search').addEventListener('input', e => { const searchTerm = e.target.value.toLowerCase(); const allItems = document.querySelectorAll('#hierarchy-tree li'); if (!searchTerm) { allItems.forEach(i => i.style.display = ''); return; } allItems.forEach(li => { const item = li.querySelector('.tree-item'); const text = item.textContent.toLowerCase(); const match = text.includes(searchTerm); li.style.display = match ? '' : 'none'; if (match) { let parentLi = li.parentElement.closest('li'); while (parentLi) { parentLi.style.display = ''; parentLi = parentLi.parentElement.closest('li'); } } }); });
                            document.getElementById('deployment-list').addEventListener('click', e => { const item = e.target.closest('.tree-item'); if (!item) return; if (e.target.classList.contains('tree-swivel')) { const children = item.nextElementSibling; if (children) { children.classList.toggle('collapsed'); e.target.textContent = children.classList.contains('collapsed') ? '‚ñ∂' : '‚ñº'; } } else { const { id, type } = item.dataset; if (type === 'pod') showPodInspector(id); if (type === 'deployment') showDeploymentInspector(id); } });

                            initThree();
                            document.getElementById('add-worker-btn').addEventListener('click', showAddNodeModal);
                            document.getElementById('confirm-add-node-btn').addEventListener('click', () => { const name = document.getElementById('new-node-name-input').value; if (name) addNode('worker', name); hideAddNodeModal(); });
                            document.getElementById('cancel-add-node-btn').addEventListener('click', hideAddNodeModal);
                            document.getElementById('new-node-name-input').addEventListener('keydown', e => { if (e.key === 'Enter') document.getElementById('confirm-add-node-btn').click(); });
                            document.getElementById('remove-worker-btn').addEventListener('click', removeLastWorkerNode);
                            document.getElementById('create-deployment-btn').addEventListener('click', createDeployment);
                            document.getElementById('create-service-btn').addEventListener('click', createService);
                            document.getElementById('close-welcome-btn').addEventListener('click', () => document.getElementById('welcome-panel').style.display = 'none');
                            document.getElementById('close-inspector-btn').addEventListener('click', hideInspector);
                            document.getElementById('pause-btn').addEventListener('click', () => { clusterState.isPaused = !clusterState.isPaused; document.getElementById('pause-btn').textContent = clusterState.isPaused ? 'Resume' : 'Pause'; });
                            document.getElementById('replica-slider').addEventListener('input', e => document.getElementById('replica-count-label').textContent = e.target.value);
                            document.getElementById('toggle-hierarchy-btn').addEventListener('click', e => { const panel = document.getElementById('hierarchy-panel'); panel.classList.toggle('collapsed'); e.target.textContent = panel.classList.contains('collapsed') ? '¬´' : '¬ª'; });
                            document.getElementById('select-tool').addEventListener('click', () => setTool('select'));
                            document.getElementById('navigate-tool').addEventListener('click', () => setTool('navigate'));
                            document.addEventListener('keydown', e => {
                                if (e.key === 's' || e.key === 'S') setTool('select');
                                if (e.key === 'v' || e.key === 'V') setTool('navigate');
                            });

                            window.sim = { scaleDeployment, failNode, killPod, simulateTraffic };
                            addNode('master', 'master-node-1'); addNode('worker', 'worker-node-1');
                            setTool('navigate');
                            updateLabelSelector(); // Initialize the label selector
                            animate(); setInterval(reconciliationLoop, 1000);
                        });
    </script>
</body>

</html>