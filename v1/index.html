<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Kubernetes Cluster Explorer</title>
    <style>
        :root {
            /* Layout Variables */
            --left-panel-width: 320px;
            --right-panel-width: 350px;
            --bottom-panel-height: 100px;
            
            /* Node Colors */
            --master-node: #2E7D32;
            --master-core: #66BB6A;
            --worker-node: #455A64;
            --pipe: #00BCD4;
            --particle: #FFFFFF;
            
            /* UI Colors */
            --ui-bg: #263238;
            --ui-bg-light: #37474F;
            --ui-text: #ECEFF1;
            --ui-text-secondary: #B0BEC5;
            --ui-accent: #00BCD4;
            --ui-accent-hover: #00ACC1;
            --ui-border: #37474F;
            
            /* Status Colors */
            --pod-running: #4CAF50;
            --pod-pending: #FFC107;
            --pod-failed: #F44336;
            
            /* Typography */
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --font-mono: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            
            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            
            /* Border Radius */
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 8px;
            
            /* Shadows */
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.15);
            --shadow-lg: 0 8px 16px rgba(0, 0, 0, 0.2);
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            background-color: #1a1a1a;
            color: var(--ui-text);
            overflow: hidden;
            display: flex;
            font-size: 14px;
            line-height: 1.5;
        }

        #cluster-container {
            position: absolute;
            top: 50px;
            left: var(--left-panel-width);
            right: var(--right-panel-width);
            bottom: var(--bottom-panel-height);
            transition: all 0.3s ease;
        }

        #cluster-container.navigate-tool {
            cursor: grab;
        }

        #cluster-container.navigate-tool:active {
            cursor: grabbing;
        }

        #cluster-container.select-tool {
            cursor: pointer;
        }

        .label {
            color: var(--ui-text);
            background: rgba(0, 0, 0, 0.75);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-sm);
            font-size: 13px;
            font-weight: 500;
            pointer-events: none;
            backdrop-filter: blur(4px);
        }

        .pod-label {
            font-size: 11px;
            padding: 2px 6px;
            background: rgba(0, 0, 0, 0.6);
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .deployment-label {
            font-size: 13px;
            font-weight: 600;
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-sm);
            border: 2px solid;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            letter-spacing: 0.3px;
        }

        .panel {
            background-color: var(--ui-bg);
            box-shadow: var(--shadow-lg);
            z-index: 10;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #top-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 50px;
            background-color: var(--ui-bg);
            border-bottom: 1px solid var(--ui-border);
            display: flex;
            align-items: center;
            padding: 0 var(--spacing-lg);
            box-sizing: border-box;
            gap: var(--spacing-md);
            z-index: 20;
            box-shadow: var(--shadow-sm);
            justify-content: space-between;
        }
        
        #label-mode-indicator {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            color: var(--ui-text-secondary);
            font-size: 13px;
            font-weight: 500;
            background: var(--ui-bg-light);
            padding: 6px 16px;
            border-radius: var(--radius-lg);
            border: 1px solid var(--ui-border);
            white-space: nowrap;
        }
        
        #label-mode-indicator span {
            color: var(--ui-accent);
            font-size: 11px;
            margin-left: 8px;
            opacity: 0.8;
        }

        #left-panel {
            position: fixed;
            top: 50px;
            left: 0;
            width: var(--left-panel-width);
            height: calc(100vh - 50px);
            background: rgba(38, 50, 56, 0.85);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            z-index: 10;
        }
        
        #left-panel-content {
            flex: 1;
            padding: var(--spacing-lg);
            overflow-y: auto;
        }
        
        .panel-resize-handle {
            position: absolute;
            background: transparent;
            cursor: ew-resize;
            z-index: 100;
        }
        
        .panel-resize-handle:hover,
        .panel-resize-handle.dragging {
            background: var(--ui-accent);
            opacity: 0.5;
        }
        
        .panel-resize-handle.vertical {
            top: 0;
            bottom: 0;
            width: 4px;
            right: -2px;
        }
        
        .panel-resize-handle.horizontal {
            left: 0;
            right: 0;
            height: 4px;
            cursor: ns-resize;
        }

        #right-panel {
            position: fixed;
            top: 50px;
            right: 0;
            width: var(--right-panel-width);
            height: calc(100vh - 50px);
            background: rgba(38, 50, 56, 0.85);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            z-index: 10;
        }
        
        #hierarchy-section {
            height: 50%;
            display: flex;
            flex-direction: column;
            border-bottom: 1px solid var(--ui-border);
        }
        
        #inspector-section {
            height: 50%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        #inspector-content {
            flex: 1;
            padding: var(--spacing-lg);
            overflow-y: auto;
        }
        
        .split-handle {
            height: 4px;
            background: transparent;
            cursor: ns-resize;
            position: relative;
            z-index: 20;
        }
        
        .split-handle:hover,
        .split-handle.dragging {
            background: var(--ui-accent);
            opacity: 0.5;
        }

        #bottom-panel {
            position: fixed;
            bottom: 0;
            left: var(--left-panel-width);
            right: var(--right-panel-width);
            height: var(--bottom-panel-height);
            background: rgba(38, 50, 56, 0.85);
            backdrop-filter: blur(10px);
            z-index: 10;
        }
        
        #event-log {
            height: 100%;
            padding: var(--spacing-sm) var(--spacing-md);
            box-sizing: border-box;
            overflow-y: auto;
            font-family: var(--font-mono);
            font-size: 11px;
            line-height: 1.4;
        }
        
        #event-log p {
            margin: 2px 0;
            padding: 2px 0;
            opacity: 0.8;
        }
        
        #event-log p:first-child {
            opacity: 1;
            font-weight: 600;
        }

        .panel-header {
            padding: var(--spacing-md) var(--spacing-lg);
            background: rgba(0, 0, 0, 0.1);
            border-bottom: 1px solid var(--ui-border);
            font-weight: 600;
            font-size: 14px;
            color: var(--ui-accent);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        #hierarchy-header {
            padding: var(--spacing-sm) var(--spacing-md);
        }

        #hierarchy-search {
            width: 100%;
            padding: var(--spacing-sm) var(--spacing-md);
            background: var(--ui-bg-light);
            color: var(--ui-text);
            border: 1px solid transparent;
            border-radius: var(--radius-sm);
            font-size: 13px;
            transition: all 0.2s ease;
        }
        
        #hierarchy-search:focus {
            outline: none;
            border-color: var(--ui-accent);
            background: rgba(0, 188, 212, 0.05);
        }

        #hierarchy-tree {
            flex-grow: 1;
            overflow-y: auto;
            padding: var(--spacing-md);
            font-size: 13px;
        }

        #hierarchy-tree ul,
        #deployment-list ul {
            list-style-type: none;
            padding-left: 20px;
        }

        #hierarchy-tree li,
        #deployment-list li {
            margin: 4px 0;
        }

        .tree-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            cursor: pointer;
            padding: var(--spacing-xs);
            border-radius: var(--radius-sm);
            transition: background-color 0.15s ease;
        }

        .tree-item:hover {
            background: rgba(0, 188, 212, 0.08);
        }

        .tree-swivel,
        .tree-eye {
            cursor: pointer;
            user-select: none;
        }
        
        .tree-trash {
            cursor: pointer;
            user-select: none;
            margin-left: 8px;
            font-size: 14px;
            opacity: 0.6;
            transition: opacity 0.2s;
        }
        
        .tree-trash:hover {
            opacity: 1;
        }

        .tree-swivel {
            width: 1em;
            display: inline-block;
        }

        .tree-item-children.collapsed {
            display: none;
        }

        .tree-item.hidden-by-search {
            display: none;
        }

        .tree-item .role {
            font-size: 11px;
            color: var(--ui-text-secondary);
            margin-left: auto;
            padding-right: var(--spacing-sm);
            font-weight: 500;
            opacity: 0.8;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: var(--spacing-sm);
            box-shadow: 0 0 4px currentColor;
        }

        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #modal-content {
            background: var(--ui-bg);
            padding: var(--spacing-xl);
            border-radius: var(--radius-lg);
            border: 1px solid var(--ui-border);
            box-shadow: var(--shadow-lg);
            min-width: 400px;
        }

        #modal-content input {
            width: 100%;
            margin-bottom: var(--spacing-md);
            padding: var(--spacing-sm) var(--spacing-md);
            background: var(--ui-bg-light);
            color: var(--ui-text);
            border: 1px solid var(--ui-border);
            border-radius: var(--radius-sm);
            font-size: 14px;
            transition: border-color 0.2s ease;
        }
        
        #modal-content input:focus {
            outline: none;
            border-color: var(--ui-accent);
        }

        .gauge-container {
            width: 100%;
            height: 20px;
            background-color: rgba(84, 110, 122, 0.3);
            border-radius: 10px;
            margin-top: var(--spacing-sm);
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .gauge-bar {
            height: 100%;
            border-radius: 10px;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: right;
            padding-right: var(--spacing-sm);
            box-sizing: border-box;
            color: white;
            font-size: 11px;
            line-height: 20px;
            font-weight: 600;
            background-image: linear-gradient(180deg, rgba(255,255,255,0.1) 0%, transparent 100%);
        }

        .cpu-bar {
            background-color: #2196F3;
        }

        .mem-bar {
            background-color: var(--pod-running);
        }

        .tool-btn {
            font-size: 16px;
            padding: var(--spacing-sm) var(--spacing-md);
            background: var(--ui-bg-light);
            color: var(--ui-text);
            border: 1px solid transparent;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }
        
        .tool-btn:hover {
            background: rgba(0, 188, 212, 0.1);
            border-color: var(--ui-accent);
        }

        .tool-btn.active {
            background: var(--ui-accent);
            color: white;
            box-shadow: var(--shadow-sm);
        }

        h2,
        h3 {
            color: var(--ui-accent);
            margin-top: 0;
            margin-bottom: var(--spacing-md);
            font-weight: 600;
        }
        
        h2 {
            font-size: 18px;
        }
        
        h3 {
            font-size: 15px;
        }

        h3 .subtitle {
            font-size: 14px;
            color: var(--ui-text);
            font-weight: 400;
            display: block;
            margin-top: 4px
        }

        button {
            background-color: var(--ui-accent);
            color: var(--ui-bg);
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 700;
            transition: background-color .2s
        }

        button:hover {
            background-color: #00acc1
        }

        button.danger {
            background-color: #f44336;
            color: var(--ui-text)
        }

        select {
            width: 100%;
            padding: 8px;
            background-color: var(--ui-border);
            color: var(--ui-text);
            border: 1px solid var(--ui-accent);
            border-radius: 4px
        }

        .info-card {
            background-color: var(--ui-border);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-size: 14px
        }

        .info-card h4,
        .info-card h5 {
            margin: 0 0 10px;
            color: var(--ui-text)
        }

        .info-card p {
            margin: 5px 0
        }

        .info-card .explanation {
            font-style: italic;
            color: #b0bec5;
            font-size: 13px;
            margin-top: 10px;
            border-left: 3px solid var(--ui-accent);
            padding-left: 10px
        }

        #welcome-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 550px;
            background: rgba(38, 50, 56, .95);
            border: 2px solid var(--ui-accent);
            border-radius: 10px;
            padding: 30px;
            z-index: 1000;
            box-shadow: 0 0 25px rgba(0, 0, 0, .7)
        }
        
        code {
            background: rgba(0, 188, 212, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 13px;
        }
        
        .control-group {
            margin-bottom: var(--spacing-xl);
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        .control-group h3 {
            margin-bottom: var(--spacing-md);
        }
        
        #top-bar > button {
            font-size: 12px;
            padding: 6px 12px;
        }
        
        input[type="range"] {
            width: 100%;
            margin: var(--spacing-sm) 0;
        }
        
        label {
            display: block;
            margin-bottom: var(--spacing-xs);
            font-size: 12px;
            font-weight: 500;
            color: var(--ui-text-secondary);
        }
    </style>
</head>

<body>

    <div id="cluster-container"></div>
    <div id="welcome-panel">
        <h2>Welcome to the Kubernetes Explorer!</h2>
        <p>This is a live 3D simulation of a Kubernetes cluster with multi-plane architecture. Services float in the
            <b>Network Plane</b>, the Control Plane manages the cluster, and Worker Nodes run Pods in the <b>Data
                Plane</b>.</p>
        <p class="explanation"><b>Interaction Modes:</b><br>- Use the <b>Tool Palette</b> in the top bar to switch
            between navigating and selecting.<br>- üñêÔ∏è <b>Navigate:</b> Pan, zoom, and rotate the camera.<br>- üëÜ
            <b>Select:</b> Click objects to inspect them or drag-and-drop Pods.</p>
        <button id="close-welcome-btn">Let's Go!</button>
    </div>

    <div id="modal-overlay">
        <div id="modal-content">
            <h4>Name New Worker Node</h4> <input type="text" id="new-node-name-input"> <button
                id="confirm-add-node-btn">Create</button> <button id="cancel-add-node-btn">Cancel</button>
        </div>
    </div>
    <div id="top-bar">
        <div>
            <button id="add-worker-btn" data-label="Add Worker">Add Worker</button>
            <button id="remove-worker-btn" data-label="Remove Worker">Remove Worker</button>
            <button id="pause-btn">Pause</button>
        </div>
        <div id="label-mode-indicator">
            <span id="label-mode-text">Kubernetes Terminology Mode</span>
            <span>Press TAB to switch</span>
        </div>
        <div style="display:flex; gap: 10px; align-items: center;">
            <span style="color: #B0BEC5; font-size: 12px;">Tool:</span>
            <button id="select-tool" class="tool-btn" title="Select Tool (S) - Drag pods between nodes">üëÜ Select</button>
            <button id="navigate-tool" class="tool-btn active" title="Navigate Tool (V) - Click to inspect, drag to rotate">üñêÔ∏è Navigate</button>
        </div>
    </div>
    <!-- Left Panel -->
    <div id="left-panel">
        <div class="panel-resize-handle vertical"></div>
        <div id="left-panel-content">
        <div class="control-group">
            <h3>Cluster Overview</h3>
            <div class="info-card">
                <p>Nodes: <span id="node-count-str">1 Master, 1 Worker</span></p>
                <p>Total Pods: <span id="pod-count">0</span></p>
            </div>
        </div>
        <div class="control-group">
            <h3>Cluster Resource Pool</h3>
            <div class="info-card" id="resource-pool-stats"> <label>Aggregated CPU Usage:</label>
                <div class="gauge-container">
                    <div class="gauge-bar cpu-bar" id="total-cpu-gauge" style="width: 0%;"></div>
                </div><label>Aggregated Memory Usage:</label>
                <div class="gauge-container">
                    <div class="gauge-bar mem-bar" id="total-mem-gauge" style="width: 0%;"></div>
                </div>
            </div>
        </div>
        <div class="control-group">
            <h3>Create Deployment</h3>
            <div class="info-card"> <label for="image-select">Container Image:</label> <select id="image-select">
                    <option value="nginx" data-cpu="100" data-mem="128">nginx (small web server)</option>
                    <option value="redis" data-cpu="200" data-mem="256">redis (medium cache)</option>
                    <option value="postgres" data-cpu="500" data-mem="512">postgres (large database)</option>
                </select> <br><br> <label for="replica-slider">Replicas: <span id="replica-count-label">3</span></label>
                <input type="range" id="replica-slider" min="1" max="10" value="3">
                <p class="explanation" data-label="replicas-explanation">This tells the Deployment how many identical <b>Pods</b> (replicas) to keep
                    running.</p> <br> <button id="create-deployment-btn" data-label="Create Deployment">Create Deployment</button>
            </div>
        </div>
        <div class="control-group">
            <h3>Active Deployments</h3>
            <div id="deployment-list" class="info-card" style="padding: 10px;"></div>
        </div>
        <div class="control-group">
            <h3>Create Service<span class="subtitle">(Network Layer)</span></h3>
            <div class="info-card"> 
                <label for="service-name-input" data-label="Service Name">Service Name:</label>
                <input type="text" id="service-name-input" placeholder="my-service">
                <label for="service-type-selector" data-label="Service Type">Service Type:</label>
                <select id="service-type-selector">
                    <option value="ClusterIP">ClusterIP (Internal only)</option>
                    <option value="NodePort">NodePort (External via node ports)</option>
                    <option value="LoadBalancer" selected>LoadBalancer (External via cloud LB)</option>
                </select>
                <label for="service-label-selector" data-label="Label Selector">Label Selector:</label>
                <select id="service-label-selector" multiple
                    style="min-height: 80px;">
                </select>
                <button id="create-service-btn" data-label="Create Service">Create Service</button>
                <p class="explanation" data-label="service-explanation">Services use label selectors to find pods. Select one or more labels from the dropdown.<br>Hold Ctrl/Cmd to select multiple labels.</p>
            </div>
        </div>
        <div class="control-group">
            <h3>Active Services</h3>
            <div id="service-list"></div>
        </div>
        </div>
    </div>
    
    <!-- Right Panel -->
    <div id="right-panel">
        <div class="panel-resize-handle vertical" style="left: -2px;"></div>
        
        <!-- Hierarchy Section -->
        <div id="hierarchy-section">
            <div class="panel-header">Hierarchy</div>
            <div id="hierarchy-header">
                <input type="text" id="hierarchy-search" placeholder="Search...">
            </div>
            <div id="hierarchy-tree"></div>
        </div>
        
        <!-- Splitter -->
        <div class="split-handle" id="right-split"></div>
        
        <!-- Inspector Section -->
        <div id="inspector-section">
            <div class="panel-header">
                <span id="inspector-title">Inspector</span>
                <button id="close-inspector-btn" style="background: none; border: none; color: var(--ui-text); cursor: pointer; padding: 0;">‚úï</button>
            </div>
            <div id="inspector-content">
                <p style="color: var(--ui-text-secondary); text-align: center; margin-top: var(--spacing-xl);">Click on any object in the cluster to see its details here.</p>
            </div>
        </div>
    </div>
    
    <!-- Bottom Panel -->
    <div id="bottom-panel">
        <div class="panel-resize-handle horizontal" style="top: -2px;"></div>
        <div id="event-log">
            <p>[INFO] Control Plane online. Awaiting commands.</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            // Cookie functions
            function setCookie(name, value, days) {
                const expires = new Date();
                expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
                document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
            }
            
            function getCookie(name) {
                const nameEQ = name + "=";
                const ca = document.cookie.split(';');
                for(let i = 0; i < ca.length; i++) {
                    let c = ca[i];
                    while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                    if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
                }
                return null;
            }
            
            // Check if welcome has been shown before
            const hasSeenWelcome = getCookie('k8sviz_welcome_shown');
            if (!hasSeenWelcome) {
                // Show welcome panel (it's visible by default in CSS)
                setCookie('k8sviz_welcome_shown', 'true', 365); // Remember for 1 year
            } else {
                // Hide welcome panel immediately
                document.getElementById('welcome-panel').style.display = 'none';
            }

            const CONFIG = {
                NODE_WIDTH_CPU_SCALE: 1 / 500, NODE_HEIGHT_MEM_SCALE: 1 / 1024 * 0.55, NODE_DEPTH_STORAGE: 8, POD_SCALE_FACTOR: 1 / 1024,
                APP_COLORS: { nginx: '#00ff88', redis: '#ff6347', postgres: '#4169e1', default: '#cccccc' },
                COLORS: { MASTER_NODE: 0x2E7D32, MASTER_CORE: 0x66BB6A, WORKER_NODE: 0x455A64, PIPE: 0x00BCD4, PARTICLE: 0xFFFFFF, POD_FAILED: 0xF44336, POD_PENDING: 0xFFC107, POD_RUNNING: 0x4CAF50 },
                PLANES: {
                    NETWORK: { y: 5, color: 0x00BCD4, label: 'Network Plane' },  // Reduced from 10 to 5
                    CONTROL: { y: 0.1, color: 0x2E7D32, label: 'Control Plane' },  // Slight offset to prevent z-fighting
                    DATA: { y: -5, color: 0x455A64, label: 'Data Plane' }
                }
            };

            const clusterState = { nodes: [], pods: {}, deployments: {}, services: {}, isPaused: false, nextId: 0, selectedServiceId: null };
            let scene, camera, renderer, controls, raycaster, mouse, labelRenderer;
            const threeObjects = new Map();
            let draggedPod = null, originalPodState = {}, hasDragged = false, currentTool = 'navigate';
            let useIntuitive = false; // Initialize label mode

            const labelMappings = {
                // UI Elements
                'Cluster Explorer': 'System Overview',
                'Resource Pool': 'Available Resources',
                'Hierarchy': 'System Structure',
                'Inspector': 'Details Panel',
                'Event Log': 'Activity Monitor',
                
                // Main concepts
                'Control Plane': 'Control Plane',
                'Data Plane': 'Workload Layer',
                'Network Plane': 'Traffic Layer',
                'Master Node': 'Management Server',
                'Worker Node': 'Application Server',
                
                // Objects
                'Pod': 'Container Instance',
                'Deployment': 'Container Manager',
                'Service': 'Traffic Router',
                'Container': 'App Package',
                
                // Service types
                'ClusterIP': 'Internal Only',
                'NodePort': 'Direct Access',
                'LoadBalancer': 'Managed External',
                'Load Balancer': 'External Gateway',
                
                // Control plane components
                'API Server': 'Control Plane API',
                'etcd': 'Cluster State Store',
                'Scheduler': 'Scheduler',
                'Controller Manager': 'Controller Manager',
                'kube-proxy': 'Service Rule Manager',
                
                // Actions
                'Create Deployment': 'Create Container Manager',
                'Create Service': 'Create Traffic Router',
                'Add Worker': 'Add Server',
                'Remove Worker': 'Remove Server',
                'Scale': 'Adjust Copies',
                'Kill Pod': 'Stop Instance',
                'Simulate Failure': 'Test Failure',
                
                // Descriptions
                'Label Selector': 'Container Instance Tags',
                'Service Name': 'Name',
                'Service Type': 'Routing Type',
                'Replicas': 'Copies',
                'Matching Pods': 'Matching Container Instances',
                'Active Deployments': 'Active Container Managers',
                'Active Services': 'Active Traffic Routers',
                'Nodes': 'Servers',
                'Deployments': 'Container Managers',
                'Services': 'Traffic Routers'
            };

            // Get appropriate label
            function getLabel(k8sLabel) {
                if (useIntuitive && labelMappings[k8sLabel]) {
                    return labelMappings[k8sLabel];
                }
                return k8sLabel;
            }

            function initThree() {
                const container = document.getElementById('cluster-container');
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a1a1a);
                scene.fog = new THREE.Fog(0x1a1a1a, 40, 100);
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 2000); camera.position.set(10, 15, 20);
                renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); container.appendChild(renderer.domElement);
                labelRenderer = new THREE.CSS2DRenderer(); 
                labelRenderer.setSize(window.innerWidth, window.innerHeight); 
                labelRenderer.domElement.style.position = 'absolute'; 
                labelRenderer.domElement.style.top = '0px';
                labelRenderer.domElement.style.pointerEvents = 'none'; // Don't block clicks
                container.appendChild(labelRenderer.domElement);
                controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05; controls.minDistance = 1; controls.maxDistance = 100; controls.target.set(0, 2, -5);
                const ambient = new THREE.AmbientLight(0xffffff, 0.5); scene.add(ambient); const light = new THREE.DirectionalLight(0xffffff, 0.7); light.position.set(10, 20, 5); scene.add(light);
                raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();
                createPlaneSeparators();
                createExternalLoadBalancer();
                window.addEventListener('resize', onWindowResize, false);
                renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
                renderer.domElement.addEventListener('pointermove', onPointerMove, false);
                renderer.domElement.addEventListener('pointerup', onPointerUp, false);
                
                // Click handler for navigate tool
                renderer.domElement.addEventListener('click', (event) => {
                    if (currentTool === 'navigate' || currentTool === 'select') {
                        // Get intersections
                        const intersects = getIntersects(event);
                        
                        // Try to find clickable object
                        if (intersects.length > 0) {
                            let found = false;
                            
                            // Check each intersection and their parents
                            for (let i = 0; i < intersects.length; i++) {
                                const obj = intersects[i].object;
                                let target = obj;
                                
                                // Check the object and its parents for userData
                                while (target) {
                                    if (target.userData && (target.userData.id !== undefined || target.userData.serviceId !== undefined)) {
                                        found = true;
                                        
                                        const { id, type, serviceId } = target.userData;
                                        
                                        if (type === 'node' && id !== undefined) {
                                            showNodeInspector(id);
                                        }
                                        else if (type === 'pod' && id !== undefined) {
                                            showPodInspector(id);
                                        }
                                        else if (type === 'deployment' && id !== undefined) {
                                            showDeploymentInspector(id);
                                        }
                                        else if (type === 'service-filter' && serviceId !== undefined) {
                                            showServiceInspector(serviceId);
                                            clusterState.selectedServiceId = serviceId;
                                        }
                                        else if (type === 'controlPlane' && id !== undefined) {
                                            showControlPlaneInspector(obj.userData.component);
                                        }
                                        break;
                                    }
                                    target = target.parent;
                                }
                                
                                if (found) break;
                            }
                            
                            if (!found) {
                                hideInspector();
                            }
                        } else {
                            hideInspector();
                        }
                    }
                });
            }

            function getNextId() { return clusterState.nextId++; }
            function addNode(type, name) { if (clusterState.nodes.length >= 101) { logEvent('Cluster at maximum node capacity (100 workers).', 'WARN'); return; } const id = getNextId(); const node = { id, type, name: name || `${type}-node-${id}`, pods: new Set(), cpu: { usage: 0 }, memory: { usage: 0 }, isFailing: false, isVisible: true }; if (type === 'worker') { node.cpu.capacity = 4000; node.memory.capacity = 8192; } clusterState.nodes.push(node); createNodeVisual(node); logEvent(`${node.name} (${type}) is online.`); updateClusterOverview(); renderHierarchy(); }
            function removeWorkerNode(nodeId) {
                const node = nodeId ? 
                    clusterState.nodes.find(n => n.id === nodeId && n.type === 'worker') :
                    [...clusterState.nodes].reverse().find(n => n.type === 'worker');
                    
                if (!node) return;
                
                // Evacuate pods first
                failNode(node.id, true);
                
                // Remove node
                const nodeIndex = clusterState.nodes.indexOf(node);
                clusterState.nodes.splice(nodeIndex, 1);
                
                // Remove visual
                const nodeMesh = threeObjects.get(node.id);
                if (nodeMesh) {
                    scene.remove(nodeMesh);
                    threeObjects.delete(node.id);
                }
                
                repositionNodes();
                updateResourcePoolView();
                renderHierarchy();
                updateNodePortIndicators();
                
                logEvent(`Worker node ${node.name} removed.`);
            }
            
            function removeLastWorkerNode() {
                removeWorkerNode();
            }
            function createDeployment() { const option = document.getElementById('image-select').selectedOptions[0]; const depId = getNextId(); const newDep = { id: depId, name: `${option.value}-deployment-${depId}`, replicas: parseInt(document.getElementById('replica-slider').value, 10), image: option.value, cpuRequest: parseInt(option.dataset.cpu), memRequest: parseInt(option.dataset.mem), podIds: new Set(), isVisible: true }; clusterState.deployments[newDep.id] = newDep; logEvent(`Deployment '${newDep.name}' created. Goal: ${newDep.replicas} replicas.`); updateDeploymentList(); renderHierarchy(); }
            function createService() {
                const nameInput = document.getElementById('service-name-input');
                const serviceName = nameInput.value.trim();
                const serviceType = document.getElementById('service-type-selector').value;
                
                const select = document.getElementById('service-label-selector');
                const selectedOptions = Array.from(select.selectedOptions);
                if (selectedOptions.length === 0) {
                    logEvent('Please select at least one label from the dropdown', 'WARN');
                    return;
                }
                
                const selector = {};
                selectedOptions.forEach(option => {
                    const [key, value] = option.value.split('=');
                    if (key && value) selector[key] = value;
                });

                const srvId = getNextId();
                const newSrv = {
                    id: srvId,
                    name: serviceName || `service-${srvId}`,  // Use custom name or default
                    type: serviceType,
                    selector: selector,
                    isVisible: true,
                    networkLines: [],
                    nodePort: serviceType === 'NodePort' ? 30000 + Math.floor(Math.random() * 2768) : null, // Random NodePort 30000-32767
                    trafficParticles: []
                };
                clusterState.services[srvId] = newSrv;
                createServiceVisual(newSrv);
                updateNodePortIndicators(); // Update port indicators on nodes
                const selectorStr = Object.entries(selector).map(([k, v]) => `${k}=${v}`).join(', ');
                logEvent(`${serviceType} Service '${newSrv.name}' created with selector: ${selectorStr}`);
                updateServiceList();
                renderHierarchy();
                nameInput.value = '';  // Clear the input for next service
            }
            function scaleDeployment(id, reps) { const deployment = clusterState.deployments[id]; if (!deployment) return; logEvent(`Scaling '${deployment.name}' from ${deployment.replicas} to ${reps} replicas.`); deployment.replicas = reps; updateDeploymentList(); }
            function terminatePod(podId, reason) { const pod = clusterState.pods[podId]; if (!pod || pod.status === 'Terminating') return; pod.status = 'Terminating'; const podMesh = threeObjects.get(podId); if (podMesh) new TWEEN.Tween(podMesh.scale).to({ x: 0, y: 0, z: 0 }, 500).onComplete(() => { podMesh.parent?.remove(podMesh); threeObjects.delete(podId); recalculateServicePositions(); }).start(); if (pod.nodeId) { const node = clusterState.nodes.find(n => n.id === pod.nodeId); if (node) { node.pods.delete(podId); recalculateNodeResources(node); } } const dep = clusterState.deployments[pod.deploymentId]; if (dep) dep.podIds.delete(podId); logEvent(`Pod ${pod.name} was ${reason}.`); setTimeout(() => { delete clusterState.pods[podId]; renderHierarchy(); updateDeploymentList(); updateLabelSelector(); }, 500); }
            function failNode(nodeId, isRemoval = false) { const node = clusterState.nodes.find(n => n.id === nodeId); if (!node || node.type === 'master') return; node.isFailing = true; const nodeGroup = threeObjects.get(nodeId); if (nodeGroup) { const nodeMesh = nodeGroup.children.find(child => child.type === 'Mesh' && child.userData.isNodeBox); if (nodeMesh && nodeMesh.material) nodeMesh.material.color.set(CONFIG.COLORS.POD_FAILED); } logEvent(`Worker Node ${node.name} is failing! Evacuating pods...`, 'ERROR'); Array.from(node.pods).forEach(podId => { const pod = clusterState.pods[podId]; if (!pod) return; pod.status = 'Pending'; pod.nodeId = null; const podMesh = threeObjects.get(podId); if (podMesh) { const worldPos = new THREE.Vector3(); podMesh.getWorldPosition(worldPos); scene.attach(podMesh); podMesh.position.copy(worldPos); podMesh.material.color.set(CONFIG.COLORS.POD_PENDING); } }); node.pods.clear(); recalculateNodeResources(node); renderHierarchy(); if (isRemoval) return; setTimeout(() => { node.isFailing = false; if (nodeGroup) { const nodeMesh = nodeGroup.children.find(child => child.type === 'Mesh' && child.userData.isNodeBox); if (nodeMesh && nodeMesh.material) nodeMesh.material.color.set(CONFIG.COLORS.WORKER_NODE); } logEvent(`Worker Node ${node.name} has recovered.`); updateResourcePoolView(); }, 1e4); }
            function killPod(podId) { const pod = clusterState.pods[podId]; if (!pod) return; pod.status = 'Failed'; const podMesh = threeObjects.get(podId); if (podMesh) podMesh.material.color.set(CONFIG.COLORS.POD_FAILED); logEvent(`Pod ${pod.name} killed! Control Plane will replace it.`, 'WARN'); setTimeout(() => { if (clusterState.pods[podId]?.status === 'Failed') terminatePod(podId, "cleaned up"); }, 2e3); }
            function findSchedulableNode(cpu, mem) { return clusterState.nodes.find(n => n.type === 'worker' && !n.isFailing && (n.cpu.usage + cpu <= n.cpu.capacity) && (n.memory.usage + mem <= n.memory.capacity)); }
            function deleteDeployment(deploymentId) {
                const dep = clusterState.deployments[deploymentId];
                if (!dep) return;
                
                // Delete all pods belonging to this deployment
                Array.from(dep.podIds).forEach(podId => {
                    terminatePod(podId, 'deployment deleted');
                });
                
                // Remove deployment visual
                const depMesh = threeObjects.get(`dep-${dep.id}`);
                if (depMesh) {
                    scene.remove(depMesh);
                    threeObjects.delete(`dep-${dep.id}`);
                }
                
                // Remove from state
                delete clusterState.deployments[deploymentId];
                
                // Update UI
                updateDeploymentList();
                renderHierarchy();
                hideInspector();
                
                logEvent(`Deployment ${dep.name} deleted.`, 'INFO');
            }
            
            function deleteService(serviceId) {
                const srv = clusterState.services[serviceId];
                if (!srv) return;
                
                // Remove network lines associated with this service
                if (srv.networkLines) {
                    srv.networkLines.forEach(line => scene.remove(line));
                    srv.networkLines = [];
                }
                
                // Remove from state
                delete clusterState.services[serviceId];
                
                // Update UI
                updateKubeProxyServiceFilters();
                updateServiceList();
                updateNodePortIndicators(); // Remove port indicators if NodePort
                renderHierarchy();
                hideInspector();
                
                logEvent(`Service ${srv.name} deleted.`, 'INFO');
            }
            
            function simulateTraffic(serviceId) {
                console.log('simulateTraffic called for service:', serviceId);
                const srv = clusterState.services[serviceId]; 
                if (!srv) return;
                
                // Initialize round-robin counter if not exists
                if (!srv.roundRobinIndex) srv.roundRobinIndex = 0;
                
                // Find pods that match the service's label selector
                const matchingPods = Object.values(clusterState.pods).filter(pod => {
                    if (!pod.labels || !srv.selector || pod.status !== 'Running') return false;
                    return Object.entries(srv.selector).every(([key, value]) => pod.labels[key] === value);
                });
                
                if (matchingPods.length === 0) {
                    logEvent(`No running pods match service ${srv.name}`, 'WARN');
                    return;
                }
                
                // Create a stream of 10 requests with round-robin load balancing
                const numRequests = 10;
                const requestDelay = 300; // ms between requests
                
                for (let i = 0; i < numRequests; i++) {
                    setTimeout(() => {
                        // Round-robin pod selection
                        const targetPod = matchingPods[srv.roundRobinIndex % matchingPods.length];
                        srv.roundRobinIndex++;
                        
                        const targetPodMesh = threeObjects.get(targetPod.id);
                        if (!targetPodMesh) return;
                        
                        const targetNode = clusterState.nodes.find(n => n.id === targetPod.nodeId);
                        if (!targetNode) return;
                        
                        animateSingleRequest(srv, targetPod, targetPodMesh, targetNode, i, matchingPods);
                    }, i * requestDelay);
                }
            }
            
            function animateSingleRequest(srv, targetPod, targetPodMesh, targetNode, requestIndex, matchingPods) {
                
                // Helper function to pulse a cable
                function pulseCable(line) {
                    if (!line || !line.material) return;
                    const origOpacity = line.material.opacity;
                    const origLinewidth = line.material.linewidth || 2;
                    new TWEEN.Tween(line.material)
                        .to({ opacity: 0.8, linewidth: origLinewidth * 1.5 }, 300)
                        .chain(new TWEEN.Tween(line.material)
                            .to({ opacity: origOpacity, linewidth: origLinewidth }, 300))
                        .start();
                }
                
                // Find relevant cables/lines for this traffic flow
                const cables = [];
                const cablesToPulse = [];
                
                // Determine traffic source and build cable path
                let sourcePos;
                let sourceName;
                
                // Find the iptables to pod cable
                const iptablesToPodLine = srv.networkLines.find(line => 
                    line.userData.type === 'iptables-to-pod' && 
                    line.userData.podId === targetPod.id
                );
                
                if (srv.type === 'ClusterIP' || !srv.type) {
                    // Internal traffic: goes directly to pod (bypassing kube-proxy)
                    const nodeMesh = threeObjects.get(targetNode.id);
                    if (nodeMesh) {
                        sourcePos = new THREE.Vector3();
                        nodeMesh.getWorldPosition(sourcePos);
                        sourcePos.y += 2; // Start from network layer above node
                        sourceName = 'Internal';
                        
                        // No cable to pulse for internal traffic - it goes directly
                    }
                } else if (srv.type === 'NodePort') {
                    // External traffic through NodePort: goes directly to node then to pod
                    const nodeMesh = threeObjects.get(targetNode.id);
                    if (nodeMesh) {
                        sourcePos = new THREE.Vector3();
                        nodeMesh.getWorldPosition(sourcePos);
                        sourcePos.x -= 5; // Start from outside the node
                        sourcePos.y += 1;
                        sourceName = 'External';
                        
                        if (iptablesToPodLine && iptablesToPodLine.userData.cable) {
                            cables.push(iptablesToPodLine.userData.cable);
                            cablesToPulse.push(iptablesToPodLine);
                        }
                        
                        logEvent(`External traffic entering through ${targetNode.name}:${srv.nodePort}`, 'INFO');
                    }
                } else if (srv.type === 'LoadBalancer') {
                    // External traffic through load balancer
                    const externalLb = threeObjects.get('external-lb');
                    
                    if (externalLb) {
                        sourcePos = externalLb.position.clone();
                        sourceName = 'External LB';
                        
                        // Find external LB to kube-proxy cable
                        const lbToKubeProxyLine = externalLb.connections?.find(line => 
                            line.userData.nodeId === targetNode.id
                        );
                        if (lbToKubeProxyLine && lbToKubeProxyLine.userData.cable) {
                            cables.push(lbToKubeProxyLine.userData.cable);
                            cablesToPulse.push(lbToKubeProxyLine);
                        }
                        
                        // Add kube-proxy to pod cable
                        if (iptablesToPodLine && iptablesToPodLine.userData.cable) {
                            cables.push(iptablesToPodLine.userData.cable);
                            cablesToPulse.push(iptablesToPodLine);
                        }
                        
                        // Animate the external LB
                        const lbMesh = externalLb.children[0];
                        if (lbMesh && lbMesh.material) {
                            const origIntensity = lbMesh.material.emissiveIntensity;
                            new TWEEN.Tween(lbMesh.material)
                                .to({ emissiveIntensity: 0.8 }, 300)
                                .chain(new TWEEN.Tween(lbMesh.material)
                                    .to({ emissiveIntensity: origIntensity }, 300))
                                .start();
                        }
                    }
                }
                
                if (!sourcePos) return;
                
                // Log the routing decision (kube-proxy configures rules but doesn't handle traffic)
                const routePath = srv.type === 'NodePort' ? 
                    `${sourceName} ‚Üí Node:${srv.nodePort} ‚Üí ${targetPod.name} (via iptables rules)` :
                    srv.type === 'LoadBalancer' ?
                    `${sourceName} ‚Üí Cloud LB ‚Üí Node ‚Üí ${targetPod.name} (via iptables rules)` :
                    `${sourceName} ‚Üí ${targetPod.name} (via iptables rules)`;
                logEvent(routePath, 'INFO');
                
                // Animate kube-proxy glow (no scaling)
                if (targetNode.kubeProxy) {
                    const originalIntensity = targetNode.kubeProxy.material.emissiveIntensity;
                    
                    // Just glow, no scale animation
                    new TWEEN.Tween(targetNode.kubeProxy.material)
                        .to({ emissiveIntensity: 0.8 }, 200)
                        .chain(new TWEEN.Tween(targetNode.kubeProxy.material)
                            .to({ emissiveIntensity: originalIntensity }, 200))
                        .start();
                }
                
                // Pulse the cables
                cablesToPulse.forEach(cable => pulseCable(cable));
                
                // Get the pod position
                const podPos = new THREE.Vector3();
                targetPodMesh.getWorldPosition(podPos);
                
                // Create path through iptables if available
                let combinedPath;
                if (iptablesToPodLine && iptablesToPodLine.userData.cable) {
                    // Follow the iptables cable path
                    combinedPath = iptablesToPodLine.userData.cable;
                } else {
                    // Fallback to direct path
                    const midPoint = new THREE.Vector3(
                        (sourcePos.x + podPos.x) / 2,
                        Math.max(sourcePos.y, podPos.y) + 1,
                        (sourcePos.z + podPos.z) / 2
                    );
                    combinedPath = new THREE.CatmullRomCurve3([sourcePos, midPoint, podPos]);
                }
                
                // Create a small white pearl particle (20% of previous size)
                const requestGeom = new THREE.SphereGeometry(0.05, 8, 8);
                const requestMat = new THREE.MeshPhongMaterial({ 
                    color: 0xFFFFFF,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 0.5,
                    shininess: 100
                });
                const requestParticle = new THREE.Mesh(requestGeom, requestMat);
                requestParticle.position.copy(sourcePos);
                scene.add(requestParticle);
                
                // Add a subtle glow
                const auraGeom = new THREE.SphereGeometry(0.07, 8, 8);
                const auraMat = new THREE.MeshBasicMaterial({
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.2
                });
                const aura = new THREE.Mesh(auraGeom, auraMat);
                requestParticle.add(aura);
                
                // Animate request particle along cable path (faster: 3 seconds)
                const requestTween = new TWEEN.Tween({ t: 0 })
                    .to({ t: 1 }, 3000)
                    .easing(TWEEN.Easing.Quadratic.InOut)
                    .onUpdate(({ t }) => {
                        combinedPath.getPointAt(t, requestParticle.position);
                        // Subtle pulse
                        const scale = 1 + Math.sin(t * Math.PI * 4) * 0.1;
                        requestParticle.scale.setScalar(scale);
                        aura.scale.setScalar(1.3 * scale);
                    })
                    .onComplete(() => {
                        scene.remove(requestParticle);
                        
                        // Animate target pod
                        if (targetPodMesh && targetPodMesh.material) {
                            const origEmissive = targetPodMesh.material.emissiveIntensity || 0;
                            targetPodMesh.material.emissive = new THREE.Color(0x00FF00);
                            new TWEEN.Tween(targetPodMesh.material)
                                .to({ emissiveIntensity: 0.5 }, 200)
                                .chain(new TWEEN.Tween(targetPodMesh.material)
                                    .to({ emissiveIntensity: origEmissive }, 200))
                                .start();
                        }
                        
                        // Create small response particle (blue)
                        const responseGeom = new THREE.SphereGeometry(0.05, 8, 8);
                        const responseMat = new THREE.MeshPhongMaterial({ 
                            color: 0x2196F3,
                            emissive: 0x2196F3,
                            emissiveIntensity: 0.5,
                            shininess: 100
                        });
                        const responseParticle = new THREE.Mesh(responseGeom, responseMat);
                        responseParticle.position.copy(podPos);
                        scene.add(responseParticle);
                        
                        // Add response glow
                        const respAuraGeom = new THREE.SphereGeometry(0.07, 8, 8);
                        const respAuraMat = new THREE.MeshBasicMaterial({
                            color: 0x2196F3,
                            transparent: true,
                            opacity: 0.2
                        });
                        const respAura = new THREE.Mesh(respAuraGeom, respAuraMat);
                        responseParticle.add(respAura);
                        
                        // Animate response back along same cable
                        new TWEEN.Tween({ t: 0 })
                            .to({ t: 1 }, 2500)
                            .easing(TWEEN.Easing.Quadratic.InOut)
                            .onUpdate(({ t }) => {
                                // Reverse path for response
                                combinedPath.getPointAt(1 - t, responseParticle.position);
                                const scale = 1 + Math.sin(t * Math.PI * 4) * 0.1;
                                responseParticle.scale.setScalar(scale);
                                respAura.scale.setScalar(1.3 * scale);
                            })
                            .onComplete(() => {
                                scene.remove(responseParticle);
                                if (requestIndex === 0) {
                                    logEvent(`Traffic routed to pods: ${matchingPods.map(p => p.name).join(', ')}`, 'INFO');
                                }
                            })
                            .start();
                    })
                    .start();
            }
            function createPlaneSeparators() {
                const planeSize = 50;
                Object.entries(CONFIG.PLANES).forEach(([key, plane]) => {
                    // Create semi-transparent plane
                    const planeGeom = new THREE.PlaneGeometry(planeSize, planeSize);
                    const planeMat = new THREE.MeshBasicMaterial({
                        color: plane.color,
                        transparent: true,
                        opacity: 0.02,
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });
                    const planeMesh = new THREE.Mesh(planeGeom, planeMat);
                    planeMesh.rotation.x = -Math.PI / 2;
                    planeMesh.position.y = plane.y;
                    planeMesh.userData = { type: 'plane', name: key };
                    planeMesh.frustumCulled = false;
                    planeMesh.renderOrder = -50;
                    scene.add(planeMesh);
                    threeObjects.set(`plane-${key}`, planeMesh);

                    // Add plane label
                    const label = createHtmlLabel(getLabel(plane.label), new THREE.Vector3(25, plane.y, 0));
                    label.element.style.fontSize = '18px';
                    label.element.style.fontWeight = 'bold';
                    label.element.style.color = '#' + plane.color.toString(16).padStart(6, '0');
                    scene.add(label);
                    planeMesh.label = label; // Store reference for updates
                });
                
                // Create external traffic source (Internet cloud)
                const internetGroup = new THREE.Group();
                
                // Create stylized cloud shape for internet
                const internetMat = new THREE.MeshBasicMaterial({ 
                    color: 0x4A90E2,
                    transparent: true, 
                    opacity: 0.6,
                    side: THREE.DoubleSide 
                });
                
                // Build cloud from spheres
                const cloudPositions = [
                    { x: 0, y: 0, z: 0, scale: 2 },
                    { x: 1.5, y: 0, z: 0, scale: 1.5 },
                    { x: -1.5, y: 0, z: 0, scale: 1.5 },
                    { x: 0.8, y: 0, z: 1.2, scale: 1.3 },
                    { x: -0.8, y: 0, z: 1.2, scale: 1.3 },
                    { x: 0.8, y: 0, z: -1.2, scale: 1.3 },
                    { x: -0.8, y: 0, z: -1.2, scale: 1.3 }
                ];
                
                cloudPositions.forEach(pos => {
                    const sphere = new THREE.Mesh(
                        new THREE.SphereGeometry(0.8 * pos.scale, 16, 16),
                        internetMat
                    );
                    sphere.position.set(pos.x, pos.y, pos.z);
                    internetGroup.add(sphere);
                });
                
                // Add world icon in center
                const worldGeom = new THREE.SphereGeometry(1.2, 32, 16);
                const worldMat = new THREE.MeshLambertMaterial({ 
                    color: 0xFFFFFF,
                    emissive: 0x4A90E2,
                    emissiveIntensity: 0.3
                });
                const world = new THREE.Mesh(worldGeom, worldMat);
                internetGroup.add(world);
                
                // Position above network plane, closer to the cluster
                internetGroup.position.set(-8, CONFIG.PLANES.NETWORK.y + 8, 5);
                internetGroup.userData = { type: 'internet', id: 'internet' };
                
                // Add label
                const internetLabel = createHtmlLabel('Internet', new THREE.Vector3(0, 2, 0));
                internetLabel.element.style.fontSize = '16px';
                internetLabel.element.style.fontWeight = 'bold';
                internetGroup.add(internetLabel);
                
                scene.add(internetGroup);
                threeObjects.set('internet', internetGroup);
            }
            
            function createExternalLoadBalancer() {
                // Create external load balancer visualization
                const lbGroup = new THREE.Group();
                
                // Main sphere
                const lbGeom = new THREE.SphereGeometry(1.5, 32, 32);
                const lbMat = new THREE.MeshPhongMaterial({
                    color: 0x4285F4, // Google Cloud blue
                    emissive: 0x4285F4,
                    emissiveIntensity: 0.2,
                    transparent: true,
                    opacity: 0.8
                });
                const lbMesh = new THREE.Mesh(lbGeom, lbMat);
                lbGroup.add(lbMesh);
                
                // Add rings to indicate it's a network device
                for (let i = 0; i < 2; i++) {
                    const ringGeom = new THREE.TorusGeometry(2 + i * 0.3, 0.1, 8, 32);
                    const ringMat = new THREE.MeshBasicMaterial({
                        color: 0x4285F4,
                        opacity: 0.5 - i * 0.2,
                        transparent: true
                    });
                    const ring = new THREE.Mesh(ringGeom, ringMat);
                    ring.rotation.x = Math.PI / 2;
                    ring.rotation.z = i * Math.PI / 4;
                    lbGroup.add(ring);
                }
                
                // Position between internet and cluster
                lbGroup.position.set(-5, CONFIG.PLANES.NETWORK.y + 5, 8);
                lbGroup.userData = { type: 'loadbalancer', id: 'external-lb' };
                
                // Add label
                const lbLabel = createHtmlLabel(getLabel('Load Balancer') + ' (External)', new THREE.Vector3(0, 2, 0));
                lbLabel.element.style.fontSize = '14px';
                lbLabel.element.style.fontWeight = 'bold';
                lbGroup.add(lbLabel);
                
                scene.add(lbGroup);
                threeObjects.set('external-lb', lbGroup);
                
                // Initially hide it
                lbGroup.visible = false;
                
                return lbGroup;
            }
            function createHtmlLabel(text, pos, clickHandler = null) { 
                const div = document.createElement('div'); 
                div.className = 'label'; 
                div.textContent = text; 
                if (clickHandler) {
                    div.style.pointerEvents = 'auto';
                    div.style.cursor = 'pointer';
                    div.onclick = clickHandler;
                }
                const label = new THREE.CSS2DObject(div); 
                label.position.copy(pos); 
                return label; 
            }

            function reconciliationLoop() { if (clusterState.isPaused) return; let stateChanged = false; Object.values(clusterState.deployments).forEach(dep => { const currentPods = Array.from(dep.podIds).map(id => clusterState.pods[id]).filter(p => p && p.status !== 'Terminating'); if (currentPods.length > dep.replicas) { const podToKill = currentPods[0]; if (podToKill) { terminatePod(podToKill.id, "scaled down"); stateChanged = true; } } else if (currentPods.length < dep.replicas) { const id = getNextId(); clusterState.pods[id] = { id, deploymentId: dep.id, name: `${dep.image}-pod-${id}`, image: dep.image, status: 'Pending', nodeId: null, cpuRequest: dep.cpuRequest, memRequest: dep.memRequest, isVisible: true, labels: { app: dep.image, deployment: dep.name } }; dep.podIds.add(id); logEvent(`Pod for ${dep.name} is Pending.`); stateChanged = true; } }); Object.values(clusterState.pods).filter(p => p.status === 'Pending').forEach(pod => { const node = findSchedulableNode(pod.cpuRequest, pod.memRequest); if (node) { pod.status = 'Running'; pod.nodeId = node.id; node.pods.add(pod.id); recalculateNodeResources(node); createPodVisual(pod, node); logEvent(`Pod ${pod.name} scheduled on Node ${node.name}.`); stateChanged = true; } else { logEvent(`No available Node has enough resources for pod ${pod.name}.`, 'WARN') } }); if (stateChanged) { renderHierarchy(); updateDeploymentList(); updateLabelSelector(); } updateDeploymentVisuals(); updateServiceVisuals(); updateClusterOverview(); updateResourcePoolView(); }
            function createNodeVisual(node) {
                let mesh; if (node.type === 'master') {
                    const group = new THREE.Group(); const foundationGeom = new THREE.BoxGeometry(1, 1, 1); const foundationMat = new THREE.MeshLambertMaterial({ color: CONFIG.COLORS.MASTER_NODE, transparent: true, opacity: .6 }); const foundationMesh = new THREE.Mesh(foundationGeom, foundationMat); foundationMesh.position.y = -.5; foundationMesh.frustumCulled = false; foundationMesh.renderOrder = -2; const coreMat = new THREE.MeshLambertMaterial({ color: CONFIG.COLORS.MASTER_CORE }); node.coreMesh = new THREE.Mesh(new THREE.SphereGeometry(.5, 16, 16), coreMat); node.coreMesh.position.y = 0; group.add(foundationMesh, node.coreMesh);
                    // Add control plane component orbs
                    const components = [
                        { name: 'API Server', key: 'API Server', angle: 0, color: 0x4CAF50 },
                        { name: 'etcd', key: 'etcd', angle: Math.PI / 2, color: 0x2196F3 },
                        { name: 'Scheduler', key: 'Scheduler', angle: Math.PI, color: 0xFFC107 },
                        { name: 'Controller Manager', key: 'Controller Manager', angle: 3 * Math.PI / 2, color: 0xFF5722 }
                    ];
                    node.componentOrbs = [];
                    components.forEach(comp => {
                        const orbGeom = new THREE.SphereGeometry(0.2, 12, 12);
                        const orbMat = new THREE.MeshLambertMaterial({
                            color: comp.color,
                            emissive: comp.color,
                            emissiveIntensity: 0.3
                        });
                        const orb = new THREE.Mesh(orbGeom, orbMat);
                        orb.userData = { component: comp.name, baseAngle: comp.angle };
                        const radius = 1.5;
                        orb.position.set(
                            Math.cos(comp.angle) * radius,
                            0.3,
                            Math.sin(comp.angle) * radius
                        );
                        const label = createHtmlLabel(getLabel(comp.key), new THREE.Vector3(0, 0.3, 0));
                        label.element.style.fontSize = '10px';
                        label.element.style.padding = '2px 6px';
                        orb.add(label);
                        orb.label = label; // Store reference for updates
                        group.add(orb);
                        node.componentOrbs.push(orb);
                    });
                    mesh = group; mesh.frustumCulled = false; 
                    const masterLabel = createHtmlLabel(getLabel("Control Plane"), new THREE.Vector3(0, 1.5, 0), () => {
                        if (currentTool === 'navigate') showNodeInspector(node.id);
                    });
                    mesh.add(masterLabel);
                } else { 
                    // Worker node
                    const width = node.cpu.capacity * CONFIG.NODE_WIDTH_CPU_SCALE; 
                    const height = node.memory.capacity * CONFIG.NODE_HEIGHT_MEM_SCALE; 
                    const depth = CONFIG.NODE_DEPTH_STORAGE; 
                    
                    // Create group for worker node and its components
                    const group = new THREE.Group();
                    
                    // Main node box
                    const mat = new THREE.MeshLambertMaterial({ 
                        color: CONFIG.COLORS.WORKER_NODE, 
                        transparent: true, 
                        opacity: .2, 
                        side: THREE.DoubleSide, 
                        depthWrite: false 
                    }); 
                    const nodeBox = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), mat); 
                    nodeBox.position.y = height / 2; 
                    nodeBox.frustumCulled = false; 
                    nodeBox.renderOrder = -100; 
                    const nodeLabel = createHtmlLabel(node.name, new THREE.Vector3(0, height / 2 + .5, 0), () => {
                        if (currentTool === 'navigate') showNodeInspector(node.id);
                    });
                    nodeBox.add(nodeLabel); 
                    group.add(nodeBox);
                    
                    // Add kube-proxy visualization (small rule manager)
                    const kubeProxyGeom = new THREE.BoxGeometry(0.8, 0.4, 0.8); // 40% of enlarged size
                    const kubeProxyMat = new THREE.MeshLambertMaterial({
                        color: 0x00BCD4, // Network color
                        emissive: 0x00BCD4,
                        emissiveIntensity: 0.2
                    });
                    const kubeProxy = new THREE.Mesh(kubeProxyGeom, kubeProxyMat);
                    kubeProxy.position.set(width/2 - 1.5, height - 0.8, 0);
                    kubeProxy.userData = { type: 'kube-proxy', nodeId: node.id };
                    
                    // Add label for kube-proxy
                    const proxyLabel = createHtmlLabel(getLabel('kube-proxy'), new THREE.Vector3(0, 0.6, 0));
                    proxyLabel.element.style.fontSize = '12px';
                    proxyLabel.element.style.padding = '4px 8px';
                    proxyLabel.element.style.fontWeight = 'bold';
                    kubeProxy.add(proxyLabel);
                    kubeProxy.label = proxyLabel; // Store reference for label updates
                    
                    group.add(kubeProxy);
                    node.kubeProxy = kubeProxy; // Store reference for animations
                    
                    // Add iptables visualization (routing rules box)
                    const iptablesGeom = new THREE.BoxGeometry(1.2, 0.3, 0.8);
                    const iptablesMat = new THREE.MeshLambertMaterial({
                        color: 0xFF6B6B, // Red-orange for iptables
                        emissive: 0xFF6B6B,
                        emissiveIntensity: 0.1
                    });
                    const iptables = new THREE.Mesh(iptablesGeom, iptablesMat);
                    iptables.position.set(-width/2 + 0.8, height/2 - 0.3, 0); // Inside edge of node
                    
                    const iptablesLabel = createHtmlLabel('iptables', new THREE.Vector3(0, 0.3, 0));
                    iptablesLabel.element.style.fontSize = '11px';
                    iptables.add(iptablesLabel);
                    
                    group.add(iptables);
                    node.iptables = iptables; // Store reference
                    
                    mesh = group;
                } 
                mesh.userData = { id: node.id, type: 'node' }; 
                scene.add(mesh); 
                threeObjects.set(node.id, mesh); 
                repositionNodes();
            }
            
            function updateNodePortIndicators() {
                // Remove existing NodePort indicators
                clusterState.nodes.forEach(node => {
                    if (node.nodePortIndicators) {
                        node.nodePortIndicators.forEach(indicator => {
                            indicator.parent?.remove(indicator);
                        });
                        node.nodePortIndicators = [];
                    }
                });
                
                // Add indicators for NodePort services
                Object.values(clusterState.services).forEach(srv => {
                    if (srv.type === 'NodePort') {
                        clusterState.nodes.filter(n => n.type === 'worker').forEach(node => {
                            const nodeMesh = threeObjects.get(node.id);
                            if (!nodeMesh) return;
                            
                            // Create port indicator
                            const portGroup = new THREE.Group();
                            
                            // Port socket visual
                            const socketGeom = new THREE.CylinderGeometry(0.3, 0.25, 0.2, 8);
                            const socketMat = new THREE.MeshLambertMaterial({
                                color: 0xFFD700, // Gold color for ports
                                emissive: 0xFFD700,
                                emissiveIntensity: 0.3
                            });
                            const socket = new THREE.Mesh(socketGeom, socketMat);
                            socket.rotation.z = Math.PI / 2;
                            portGroup.add(socket);
                            
                            // Port number label
                            const portLabel = createHtmlLabel(`:${srv.nodePort}`, new THREE.Vector3(0.5, 0, 0));
                            portLabel.element.style.fontSize = '10px';
                            portLabel.element.style.color = '#FFD700';
                            portLabel.element.style.fontWeight = 'bold';
                            portGroup.add(portLabel);
                            
                            // Position on the side of the node
                            const nodeGroup = node.type === 'worker' ? nodeMesh : null;
                            if (nodeGroup) {
                                const nodeBox = nodeGroup.children[0];
                                const width = node.cpu.capacity * CONFIG.NODE_WIDTH_CPU_SCALE;
                                const height = node.memory.capacity * CONFIG.NODE_HEIGHT_MEM_SCALE;
                                
                                // Position on the left side of the node
                                portGroup.position.set(-width/2 - 0.3, height/2, 0);
                                nodeGroup.add(portGroup);
                                
                                // Store reference
                                if (!node.nodePortIndicators) node.nodePortIndicators = [];
                                node.nodePortIndicators.push(portGroup);
                            }
                        });
                    }
                });
            }
            
            function createPodVisual(pod, node) { 
                const nodeMesh = threeObjects.get(node.id); 
                if (!nodeMesh) return; 
                
                // For worker nodes, get the actual node box from the group
                const nodeBox = node.type === 'worker' ? nodeMesh.children[0] : nodeMesh;
                
                const podSize = .5 + (pod.cpuRequest + pod.memRequest) * CONFIG.POD_SCALE_FACTOR; 
                const mat = new THREE.MeshLambertMaterial({ 
                    color: new THREE.Color(CONFIG.APP_COLORS[pod.image] || CONFIG.APP_COLORS.default) 
                }); 
                const podMesh = new THREE.Mesh(new THREE.CylinderGeometry(podSize / 2, podSize / 2, podSize, 6), mat); 
                
                const nodeBoxSize = new THREE.Vector3(); 
                new THREE.Box3().setFromObject(nodeBox).getSize(nodeBoxSize); 
                const podSpacing = podSize * 1.2; 
                const podsPerRow = Math.floor(nodeBoxSize.x / podSpacing); 
                const podIndexOnNode = Array.from(node.pods).indexOf(pod.id); 
                const col = podIndexOnNode % podsPerRow; 
                const row = Math.floor(podIndexOnNode / podsPerRow); 
                
                podMesh.position.set(
                    -nodeBoxSize.x / 2 + (col * podSpacing) + podSpacing / 2, 
                    -nodeBoxSize.y / 2 + podSize / 2, 
                    -nodeBoxSize.z / 2 + (row * podSpacing) + podSpacing / 2
                ); 
                podMesh.userData = { id: pod.id, type: 'pod' }; 
                podMesh.scale.set(.01, .01, .01); 
                
                const label = createHtmlLabel(pod.image, new THREE.Vector3(0, podSize / 2 + .2, 0), () => {
                    if (currentTool === 'navigate') showPodInspector(pod.id);
                }); 
                label.element.classList.add('pod-label'); 
                podMesh.add(label); 
                
                nodeBox.add(podMesh); 
                threeObjects.set(pod.id, podMesh); 
                
                new TWEEN.Tween(podMesh.scale).to({ x: 1, y: 1, z: 1 }, 500).easing(TWEEN.Easing.Elastic.Out).start(); 
                recalculateServicePositions(); 
            }
            function createServiceVisual(srv) {
                // Services are no longer visual objects in the scene
                // Instead, we'll add them as filter badges on kube-proxy instances
                updateKubeProxyServiceFilters();
            }
            
            function updateKubeProxyServiceFilters() {
                // Update all kube-proxy instances with current services
                clusterState.nodes.filter(n => n.type === 'worker').forEach(node => {
                    if (!node.kubeProxy) return;
                    
                    // Remove existing service filter badges
                    if (node.kubeProxy.serviceFilters) {
                        node.kubeProxy.serviceFilters.forEach(filter => {
                            if (filter.label) {
                                filter.label.element.remove();
                                filter.label.parent?.remove(filter.label);
                            }
                            filter.parent?.remove(filter);
                        });
                    }
                    
                    node.kubeProxy.serviceFilters = [];
                    
                    // Add service filter badges
                    const services = Object.values(clusterState.services);
                    services.forEach((srv, index) => {
                        // Create filter badge group
                        const filterGroup = new THREE.Group();
                        
                        // Filter icon (small plane with icon)
                        const filterGeom = new THREE.PlaneGeometry(0.6, 0.3);
                        const filterMat = new THREE.MeshBasicMaterial({
                            color: 0x1976D2,
                            transparent: true,
                            opacity: 0.8,
                            side: THREE.DoubleSide
                        });
                        const filterMesh = new THREE.Mesh(filterGeom, filterMat);
                        filterGroup.add(filterMesh);
                        
                        // Add service name label
                        const labelText = srv.type === 'NodePort' ? 
                            `üîΩ ${srv.name}:${srv.nodePort}` : 
                            `üîΩ ${srv.name}`;
                        const label = createHtmlLabel(labelText, new THREE.Vector3(0, 0, 0.2));
                        label.element.style.fontSize = '10px';
                        label.element.style.padding = '2px 6px';
                        label.element.style.backgroundColor = 'rgba(25, 118, 210, 0.9)';
                        label.element.style.cursor = 'pointer';
                        label.element.onclick = () => showServiceInspector(srv.id);
                        filterGroup.add(label);
                        filterGroup.label = label;
                        
                        // Position relative to kube-proxy
                        filterGroup.position.set(1.2, -0.3 * index, 0);
                        filterGroup.userData = { serviceId: srv.id, type: 'service-filter' };
                        
                        node.kubeProxy.add(filterGroup);
                        node.kubeProxy.serviceFilters.push(filterGroup);
                    });
                });
            }
            function repositionNodes() { 
                const workers = clusterState.nodes.filter(n => n.type === 'worker'); 
                const master = clusterState.nodes.find(n => n.type === 'master'); 
                if (master) threeObjects.get(master.id).position.set(0, 0, 0); 
                const boundingBox = new THREE.Box3(); 
                workers.forEach((node, i) => { 
                    const mesh = threeObjects.get(node.id); 
                    if (mesh) { 
                        mesh.position.set((i % 2 === 0 ? -1 : 1) * 7, mesh.position.y, -8 + (Math.floor(i / 2) * -12)); 
                        boundingBox.expandByObject(mesh); 
                    } 
                }); 
                const masterMeshGroup = threeObjects.get(master.id); 
                if (masterMeshGroup) { 
                    const foundationMesh = masterMeshGroup.children[0]; 
                    if (workers.length > 0) { 
                        const size = new THREE.Vector3(); 
                        boundingBox.getSize(size); 
                        const center = new THREE.Vector3(); 
                        boundingBox.getCenter(center); 
                        foundationMesh.scale.set(size.x + 10, 1, size.z + 10); 
                        foundationMesh.position.set(center.x, -.5, center.z); 
                    } else { 
                        foundationMesh.scale.set(1, 1, 1); 
                        foundationMesh.position.set(0, -.5, 0); 
                    } 
                } 
                recalculateServicePositions(); 
            }
            function updateDeploymentVisuals() { 
                Object.values(clusterState.deployments).forEach(dep => { 
                    let depBoxVisual = threeObjects.get(`dep-${dep.id}`); 
                    const podMeshes = Array.from(dep.podIds).map(id => clusterState.pods[id] && threeObjects.get(id)).filter(Boolean); 
                    
                    if (podMeshes.length === 0) { 
                        if (depBoxVisual) { 
                            scene.remove(depBoxVisual.label); 
                            scene.remove(depBoxVisual); 
                            threeObjects.delete(`dep-${dep.id}`); 
                        } 
                        return; 
                    } 
                    
                    // Calculate bounding box from pod meshes
                    const boundingBox = new THREE.Box3(); 
                    podMeshes.forEach(podMesh => {
                        boundingBox.expandByObject(podMesh);
                    }); 
                    
                    if (!depBoxVisual) { 
                        const colorHex = CONFIG.APP_COLORS[dep.image] || CONFIG.APP_COLORS.default; 
                        const boxMat = new THREE.MeshLambertMaterial({ 
                            color: new THREE.Color(colorHex), 
                            transparent: true, 
                            opacity: .15, 
                            emissive: new THREE.Color(colorHex), 
                            emissiveIntensity: 0, 
                            side: THREE.DoubleSide, 
                            depthWrite: false 
                        }); 
                        depBoxVisual = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), boxMat); 
                        depBoxVisual.userData = { id: dep.id, type: 'deployment' }; 
                        depBoxVisual.frustumCulled = false; 
                        depBoxVisual.renderOrder = -5; // Render behind pods
                        const label = createHtmlLabel(dep.name, new THREE.Vector3()); 
                        label.element.classList.add('deployment-label'); 
                        label.element.style.color = colorHex; 
                        label.element.style.borderColor = colorHex; 
                        depBoxVisual.label = label; 
                        scene.add(depBoxVisual); 
                        scene.add(label); 
                        threeObjects.set(`dep-${dep.id}`, depBoxVisual); 
                    } 
                    
                    // Get the actual size and center from pod positions
                    const size = new THREE.Vector3(); 
                    boundingBox.getSize(size); 
                    const center = new THREE.Vector3(); 
                    boundingBox.getCenter(center); 
                    
                    if (size.x > 0 && size.y > 0 && size.z > 0) { 
                        // Add padding to the box
                        const padding = 1.2;
                        depBoxVisual.scale.set(
                            size.x + padding, 
                            size.y + padding, 
                            size.z + padding
                        ); 
                        depBoxVisual.position.copy(center); 
                        depBoxVisual.label.position.set(center.x, boundingBox.max.y + 1, center.z);
                        depBoxVisual.visible = dep.isVisible;
                        depBoxVisual.label.visible = dep.isVisible;
                    }
                }); 
            }
            function updateServiceVisuals() {
                // Check if there are any LoadBalancer services
                const hasLoadBalancerService = Object.values(clusterState.services)
                    .some(srv => srv.type === 'LoadBalancer');
                
                // Update external load balancer visibility
                const externalLb = threeObjects.get('external-lb');
                if (externalLb) {
                    externalLb.visible = hasLoadBalancerService;
                    
                    // Also hide/show the label
                    externalLb.children.forEach(child => {
                        if (child.isCSS2DObject && child.element) {
                            child.element.style.display = hasLoadBalancerService ? 'block' : 'none';
                        }
                    });
                    
                    // Remove old connections
                    if (externalLb.connections) {
                        externalLb.connections.forEach(line => scene.remove(line));
                        externalLb.connections = [];
                    }
                    
                    // Create connections to all worker nodes if visible
                    if (hasLoadBalancerService) {
                        externalLb.connections = [];
                        const lbPos = externalLb.position.clone();
                        
                        clusterState.nodes.filter(n => n.type === 'worker').forEach(node => {
                            const nodeMesh = threeObjects.get(node.id);
                            if (nodeMesh && node.iptables) {
                                const iptablesPos = new THREE.Vector3();
                                node.iptables.getWorldPosition(iptablesPos);
                                
                                // Create droopy cable connection
                                const cable = new THREE.CatmullRomCurve3([
                                    lbPos,
                                    new THREE.Vector3(
                                        (lbPos.x + iptablesPos.x) / 2,
                                        Math.min(lbPos.y, iptablesPos.y) - 2, // Droop down
                                        (lbPos.z + iptablesPos.z) / 2
                                    ),
                                    iptablesPos
                                ]);
                                
                                // Create tube geometry for proper 3D cable (half thickness)
                                const tubeGeom = new THREE.TubeGeometry(cable, 30, 0.05, 8, false);
                                const tubeMat = new THREE.MeshLambertMaterial({
                                    color: 0x4285F4,
                                    transparent: true,
                                    opacity: 0.6
                                });
                                const line = new THREE.Mesh(tubeGeom, tubeMat);
                                line.userData.cable = cable; // Store the cable curve for particle animation
                                line.userData.nodeId = node.id; // Store node reference
                                scene.add(line);
                                externalLb.connections.push(line);
                            }
                        });
                    }
                }
                
                Object.values(clusterState.services).forEach(srv => {
                    // Find pods that match the service's label selector
                    const matchingPods = Object.values(clusterState.pods).filter(pod => {
                        if (!pod.labels || !srv.selector) return false;
                        return Object.entries(srv.selector).every(([key, value]) => pod.labels[key] === value);
                    });

                    const podMeshes = matchingPods.map(pod => threeObjects.get(pod.id)).filter(Boolean);

                    // Only update network lines if they don't exist yet
                    if (!srv.networkLines) {
                        srv.networkLines = [];
                    }
                    
                    // Skip if lines already exist for this service
                    if (srv.networkLines.length > 0) {
                        return;
                    }

                    podMeshes.forEach(podMesh => {
                        const podPos = new THREE.Vector3();
                        podMesh.getWorldPosition(podPos);
                        
                        // Create connections from iptables to pods (representing routing rules)
                        const pod = Object.values(clusterState.pods).find(p => threeObjects.get(p.id) === podMesh);
                        if (pod && pod.nodeId) {
                            const node = clusterState.nodes.find(n => n.id === pod.nodeId);
                            if (node && node.iptables) {
                                const iptablesPos = new THREE.Vector3();
                                node.iptables.getWorldPosition(iptablesPos);
                                
                                // Create thin line from iptables to pod (representing routing rule)
                                const iptablesToPodCable = new THREE.CatmullRomCurve3([
                                    iptablesPos,
                                    new THREE.Vector3(
                                        (iptablesPos.x + podPos.x) / 2,
                                        Math.min(iptablesPos.y, podPos.y) - 0.3,
                                        (iptablesPos.z + podPos.z) / 2
                                    ),
                                    podPos
                                ]);
                                
                                // Create tube geometry for proper 3D cable (half thickness)
                                const tubeGeom = new THREE.TubeGeometry(iptablesToPodCable, 20, 0.025, 8, false);
                                const tubeMat = new THREE.MeshLambertMaterial({
                                    color: 0xFF6B6B, // Match iptables color
                                    transparent: true,
                                    opacity: 0.4
                                });
                                const line = new THREE.Mesh(tubeGeom, tubeMat);
                                line.userData.cable = iptablesToPodCable;
                                line.userData.type = 'iptables-to-pod';
                                line.userData.podId = pod.id;
                                line.userData.nodeId = node.id;
                                line.visible = srv.isVisible;
                                scene.add(line);
                                srv.networkLines.push(line);
                            }
                        }
                    });
                });
            }
            function recalculateServicePosition(srv) {
                // No longer needed - services are not visual objects
            }
            function recalculateServicePositions() { 
                // No longer needed - services are not visual objects
                updateServiceVisuals();
                updateKubeProxyServiceFilters();
            }
            function animate() {
                requestAnimationFrame(animate); if (clusterState.isPaused) return; const time = Date.now() * 0.001; const masterNode = clusterState.nodes.find(n => n.type === 'master'); if (masterNode?.coreMesh) {
                    masterNode.coreMesh.material.emissive.setHex(CONFIG.COLORS.MASTER_CORE); masterNode.coreMesh.material.emissiveIntensity = Math.sin(time * 3) * .4 + .6;
                    // Animate component orbs
                    if (masterNode.componentOrbs) {
                        masterNode.componentOrbs.forEach(orb => {
                            const angle = orb.userData.baseAngle + time * 0.5;
                            const radius = 1.5;
                            orb.position.set(
                                Math.cos(angle) * radius,
                                0.3 + Math.sin(time * 2 + orb.userData.baseAngle) * 0.1,
                                Math.sin(angle) * radius
                            );
                            orb.material.emissiveIntensity = 0.3 + Math.sin(time * 4 + orb.userData.baseAngle) * 0.2;
                        });
                    }
                } 
                if (clusterState.selectedServiceId) { 
                    const srv = clusterState.services[clusterState.selectedServiceId]; 
                    if (srv) { 
                        const portalMesh = threeObjects.get(`srv-${srv.id}`); 
                        if (portalMesh && portalMesh.material) { 
                            // Only update emissive if the material supports it
                            if ('emissive' in portalMesh.material) {
                                // Use the existing emissive color or create one from the base color
                                const baseColor = portalMesh.material.color || new THREE.Color(0x00BCD4);
                                portalMesh.material.emissive = portalMesh.material.emissive || baseColor.clone();
                                portalMesh.material.emissiveIntensity = Math.sin(time * 5) * .3 + .3; 
                            }
                        } 
                    } 
                } 
                
                // Animate external traffic for NodePort and LoadBalancer services
                Object.values(clusterState.services).forEach(srv => {
                    if ((srv.type === 'NodePort' || srv.type === 'LoadBalancer') && srv.isVisible) {
                        const serviceMesh = threeObjects.get(`srv-${srv.id}`);
                        const internetMesh = threeObjects.get('internet');
                        
                        if (serviceMesh && internetMesh) {
                            // Create traffic particles if not exists
                            if (!srv.trafficParticles) {
                                srv.trafficParticles = [];
                            }
                            
                            // Automatic particle creation disabled - use "Simulate Traffic" button instead
                            /*if (Math.random() < 0.02) {
                                const particleGeom = new THREE.SphereGeometry(0.15, 8, 8);
                                const particleMat = new THREE.MeshBasicMaterial({
                                    color: 0x00FF00,
                                    emissive: 0x00FF00,
                                    emissiveIntensity: 0.8
                                });
                                const particle = new THREE.Mesh(particleGeom, particleMat);
                                particle.userData = { 
                                    progress: 0,
                                    serviceId: srv.id,
                                    startPos: internetMesh.position.clone(),
                                    endPos: serviceMesh.position.clone()
                                };
                                scene.add(particle);
                                srv.trafficParticles.push(particle);
                            }*/
                            
                            // Update existing particles
                            srv.trafficParticles = srv.trafficParticles.filter(particle => {
                                particle.userData.progress += 0.015;
                                
                                if (particle.userData.progress >= 1) {
                                    scene.remove(particle);
                                    return false;
                                }
                                
                                // Interpolate position
                                const t = particle.userData.progress;
                                const startPos = particle.userData.startPos;
                                const endPos = particle.userData.endPos;
                                
                                // Create curved path
                                const height = 5 + Math.sin(t * Math.PI) * 3;
                                particle.position.x = startPos.x + (endPos.x - startPos.x) * t;
                                particle.position.y = startPos.y + (endPos.y - startPos.y) * t + height;
                                particle.position.z = startPos.z + (endPos.z - startPos.z) * t;
                                
                                // Fade in and out
                                const opacity = Math.sin(t * Math.PI);
                                particle.material.opacity = opacity;
                                particle.material.transparent = true;
                                
                                return true;
                            });
                        }
                    }
                });
                
                TWEEN.update(); 
                controls.update(); 
                renderer.render(scene, camera); 
                labelRenderer.render(scene, camera);
            }
            function onWindowResize() { 
                const leftPanel = document.getElementById('left-panel');
                const rightPanel = document.getElementById('right-panel');
                const bottomPanel = document.getElementById('bottom-panel');
                const leftWidth = leftPanel ? leftPanel.offsetWidth : 320;
                const rightWidth = rightPanel ? rightPanel.offsetWidth : 350;
                const bottomHeight = bottomPanel ? bottomPanel.offsetHeight : 100;
                
                const width = Math.max(1, window.innerWidth - leftWidth - rightWidth);
                const height = Math.max(1, window.innerHeight - 50 - bottomHeight);
                
                camera.aspect = width / height; 
                camera.updateProjectionMatrix(); 
                renderer.setSize(width, height); 
                labelRenderer.setSize(width, height); 
            }
            let navigateClickStarted = false;
            
            function onPointerDown(event) { 
                if (event.button !== 0) return; 
                
                if (currentTool === 'navigate') {
                    // Mark that a click started in navigate mode
                    navigateClickStarted = true;
                }
                
                if (currentTool === 'select') {
                    hasDragged = false; 
                    const intersects = getIntersects(event); 
                    if (intersects.length > 0) { 
                        const obj = intersects.find(i => i.object.userData.type === 'pod')?.object; 
                        if (obj) { 
                            draggedPod = obj; 
                            originalPodState = { position: draggedPod.position.clone(), parent: draggedPod.parent }; 
                            controls.enabled = false; 
                        } 
                    }
                }
            }
            function onPointerMove(event) { if (!draggedPod) return; if (!hasDragged) { hasDragged = true; document.body.style.cursor = 'grabbing'; const worldPos = new THREE.Vector3(); draggedPod.getWorldPosition(worldPos); scene.attach(draggedPod); draggedPod.position.copy(worldPos); } const intersects = getIntersects(event); const planeIntersect = intersects.find(i => i.object.userData.type === 'node'); if (planeIntersect) draggedPod.position.set(planeIntersect.point.x, draggedPod.position.y, planeIntersect.point.z); else { const pos = new THREE.Vector3(); raycaster.ray.at(10, pos); draggedPod.position.copy(pos); } }
            function onPointerUp(event) {
                
                if (currentTool !== 'select') return; 
                
                if (draggedPod) { 
                    if (hasDragged) { 
                        const intersects = getIntersects(event); 
                        const dropTarget = intersects.find(i => i.object.userData.type === 'node' && i.object.userData.id !== originalPodState.parent.userData.id)?.object; 
                        if (dropTarget) { 
                            const pod = clusterState.pods[draggedPod.userData.id]; 
                            const targetNode = clusterState.nodes.find(n => n.id === dropTarget.userData.id); 
                            if (targetNode.cpu.usage + pod.cpuRequest <= targetNode.cpu.capacity && targetNode.memory.usage + pod.memRequest <= targetNode.memory.capacity) { 
                                const oldNode = clusterState.nodes.find(n => n.id === pod.nodeId); 
                                oldNode.pods.delete(pod.id); 
                                recalculateNodeResources(oldNode); 
                                pod.nodeId = targetNode.id; 
                                targetNode.pods.add(pod.id); 
                                recalculateNodeResources(targetNode); 
                                dropTarget.add(draggedPod); 
                                repositionPodInNode(draggedPod, targetNode); 
                                logEvent(`Pod ${pod.name} moved to Node ${targetNode.name}.`); 
                            } else { 
                                logEvent(`Node ${targetNode.name} lacks resources for Pod ${pod.name}.`, 'WARN'); 
                                originalPodState.parent.add(draggedPod); 
                                repositionPodInNode(draggedPod, originalPodState.parent); 
                            } 
                        } else { 
                            originalPodState.parent.add(draggedPod); 
                            draggedPod.position.copy(originalPodState.position); 
                        } 
                        renderHierarchy(); 
                        updateDeploymentList(); 
                        draggedPod = null; 
                        controls.enabled = true; 
                        return; 
                    } else if (!hasDragged) { 
                        draggedPod = null; 
                        controls.enabled = true; 
                    } 
                } 
                
                const intersects = getIntersects(event); 
                Object.values(clusterState.deployments).forEach(d => { 
                    const box = threeObjects.get(`dep-${d.id}`); 
                    if (box) box.material.emissiveIntensity = 0; 
                }); 
                clusterState.selectedServiceId = null; 
                
                if (intersects.length > 0) { 
                    let obj = intersects.find(i => i.object.userData.id || i.object.userData.serviceId)?.object; 
                    if (obj) { 
                        if (obj.parent?.userData.type === 'node') obj = obj.parent; 
                    } 
                    if (obj?.userData) { 
                        const { id, type, serviceId } = obj.userData; 
                        if (type === 'node' && id) showNodeInspector(id); 
                        if (type === 'pod' && id) showPodInspector(id); 
                        if (type === 'deployment' && id) showDeploymentInspector(id); 
                        if (type === 'service-filter' && serviceId) { 
                            showServiceInspector(serviceId); 
                            clusterState.selectedServiceId = serviceId; 
                        } 
                    } 
                } else { 
                    hideInspector(); 
                } 
            }
            function getIntersects(event) { const canvasBounds = renderer.domElement.getBoundingClientRect(); mouse.x = ((event.clientX - canvasBounds.left) / canvasBounds.width) * 2 - 1; mouse.y = -((event.clientY - canvasBounds.top) / canvasBounds.height) * 2 + 1; raycaster.setFromCamera(mouse, camera); return raycaster.intersectObjects(scene.children, true); }
            function repositionPodInNode(podMesh, nodeMesh) { const pod = clusterState.pods[podMesh.userData.id]; const node = clusterState.nodes.find(n => n.id === nodeMesh.userData.id); const podSize = .5 + (pod.cpuRequest + pod.memRequest) * CONFIG.POD_SCALE_FACTOR; const nodeBoxSize = new THREE.Vector3(); new THREE.Box3().setFromObject(nodeMesh).getSize(nodeBoxSize); const podSpacing = podSize * 1.2; const podsPerRow = Math.floor(nodeBoxSize.x / podSpacing); const podIndexOnNode = Array.from(node.pods).indexOf(pod.id); const col = podIndexOnNode % podsPerRow; const row = Math.floor(podIndexOnNode / podsPerRow); const newPos = new THREE.Vector3(-nodeBoxSize.x / 2 + (col * podSpacing) + podSpacing / 2, -nodeBoxSize.y / 2 + podSize / 2, -nodeBoxSize.z / 2 + (row * podSpacing) + podSpacing / 2); new TWEEN.Tween(podMesh.position).to(newPos, 300).easing(TWEEN.Easing.Quadratic.Out).start(); }
            function recalculateNodeResources(node) { node.cpu.usage = 0; node.memory.usage = 0; node.pods.forEach(id => { const p = clusterState.pods[id]; if (p) { node.cpu.usage += p.cpuRequest; node.memory.usage += p.memRequest; } }); }
            function logEvent(message, level = 'INFO') { const logEl = document.getElementById('event-log'); const p = document.createElement('p'); const time = new Date().toLocaleTimeString(); p.textContent = `[${time}] [${level}] ${message}`; if (level === 'WARN') p.style.color = CONFIG.COLORS.POD_PENDING; if (level === 'ERROR') p.style.color = CONFIG.COLORS.POD_FAILED; logEl.prepend(p); if (logEl.children.length > 50) logEl.removeChild(logEl.lastChild); }
            function updateClusterOverview() { const workers = clusterState.nodes.filter(n => n.type === 'worker').length; document.getElementById('node-count-str').textContent = `1 Master, ${workers} Worker${workers !== 1 ? 's' : ''}`; document.getElementById('pod-count').textContent = Object.keys(clusterState.pods).filter(k => clusterState.pods[k].status !== 'Terminating').length; }
            function updateResourcePoolView() { const workers = clusterState.nodes.filter(n => n.type === 'worker' && !n.isFailing); let totalCpu = 0, totalMem = 0, usedCpu = 0, usedMem = 0; workers.forEach(n => { totalCpu += n.cpu.capacity; totalMem += n.memory.capacity; usedCpu += n.cpu.usage; usedMem += n.memory.usage; }); const cpuPercent = totalCpu > 0 ? (usedCpu / totalCpu * 100).toFixed(1) : 0; const memPercent = totalMem > 0 ? (usedMem / totalMem * 100).toFixed(1) : 0; document.getElementById('total-cpu-gauge').style.width = `${cpuPercent}%`; document.getElementById('total-cpu-gauge').textContent = `${usedCpu}m / ${totalCpu}m (${cpuPercent}%)`; document.getElementById('total-mem-gauge').style.width = `${memPercent}%`; document.getElementById('total-mem-gauge').textContent = `${usedMem}Mi / ${totalMem}Mi (${memPercent}%)`; }
            function updateDeploymentList() { const listEl = document.getElementById('deployment-list'); listEl.innerHTML = '<ul></ul>'; const ul = listEl.querySelector('ul'); Object.values(clusterState.deployments).forEach(dep => { const running = Array.from(dep.podIds).filter(id => clusterState.pods[id]?.status === 'Running').length; const el = document.createElement('li'); el.innerHTML = `<div class="tree-item" data-id="${dep.id}" data-type="deployment"><span class="tree-swivel">‚ñ∂</span><span style="color:${CONFIG.APP_COLORS[dep.image]}">${dep.name} (${running}/${dep.replicas})</span></div>`; const podsUl = document.createElement('ul'); podsUl.className = 'tree-item-children collapsed'; Array.from(dep.podIds).map(id => clusterState.pods[id]).filter(Boolean).forEach(pod => { const podLi = document.createElement('li'); const statusColor = { Running: CONFIG.COLORS.POD_RUNNING, Pending: CONFIG.COLORS.POD_PENDING, Failed: CONFIG.COLORS.POD_FAILED, Terminating: '#aaa' }[pod.status]; podLi.innerHTML = `<div class="tree-item" data-id="${pod.id}" data-type="pod"><span class="status-dot" style="background-color:${statusColor};"></span><span>${pod.name} on ${clusterState.nodes.find(n => n.id === pod.nodeId)?.name || 'N/A'}</span></div>`; podsUl.appendChild(podLi); }); el.appendChild(podsUl); ul.appendChild(el); }); }
            function showNodeInspector(nodeId) { 
                const node = clusterState.nodes.find(n => n.id === nodeId); 
                if (!node) return; 
                const nodeType = node.type === 'master' ? getLabel('Master Node') : getLabel('Worker Node');
                document.getElementById('inspector-title').textContent = `${nodeType}: ${node.name}`; 
                let content = ''; 
                if (node.type === 'master') { 
                    content = `<div class="info-card">
                        <h5>What is this?</h5>
                        <p class="explanation">A <b>${getLabel('Master Node')}</b> runs the <b>${getLabel('Control Plane')}</b> components (the orbiting spheres) which manage the entire cluster:<br>
                        ‚Ä¢ <b>${getLabel('API Server')}</b> (green) - Entry point for all operations<br>
                        ‚Ä¢ <b>${getLabel('etcd')}</b> (blue) - Distributed key-value store<br>
                        ‚Ä¢ <b>${getLabel('Scheduler')}</b> (yellow) - Assigns ${getLabel('Pod')}s to nodes<br>
                        ‚Ä¢ <b>${getLabel('Controller Manager')}</b> (orange) - Maintains desired state</p>
                    </div>`; 
                } else { 
                    const cpuUsage = ((node.cpu.usage / node.cpu.capacity) * 100).toFixed(1); 
                    const memUsage = ((node.memory.usage / node.memory.capacity) * 100).toFixed(1); 
                    content = `<div class="info-card">
                        <h5>What is this?</h5>
                        <p class="explanation">A <b>${getLabel('Worker Node')}</b> IS a machine (virtual or physical) that runs your ${getLabel('Pod')}s. It contributes its CPU and Memory to the cluster-wide <b>${getLabel('Resource Pool')}</b> shown on the left.</p>
                    </div>
                    <div class="info-card">
                        <h4>Node Capacity & Usage</h4>
                        <p>CPU: ${node.cpu.usage}m / ${node.cpu.capacity}m (${cpuUsage}%)</p>
                        <p>Memory: ${node.memory.usage}Mi / ${node.memory.capacity}Mi (${memUsage}%)</p>
                        <p>${getLabel('Pod')}s Running: ${node.pods.size}</p>
                        <br><button class="danger" onclick="window.sim.failNode(${node.id})">${getLabel('Simulate Failure')}</button>
                    </div>`; 
                } 
                document.getElementById('inspector-content').innerHTML = content; 
            }
            function showPodInspector(podId) { 
                const pod = clusterState.pods[podId]; 
                if (!pod) return; 
                document.getElementById('inspector-title').textContent = `${getLabel('Pod')}: ${pod.name}`; 
                const labelsStr = pod.labels ? Object.entries(pod.labels).map(([k, v]) => `${k}=${v}`).join(', ') : 'None';
                document.getElementById('inspector-content').innerHTML = `
                    <div class="info-card">
                        <h5>What is this?</h5>
                        <p class="explanation">A <b>${getLabel('Pod')}</b> is a wrapper around one or more <b>${getLabel('Container')}s</b>. Usually it's just one container, but sometimes multiple containers work together as a unit. The ${getLabel('Pod')} is the smallest unit that can be scheduled to run on a ${getLabel('Worker Node')}.</p>
                    </div>
                    <div class="info-card">
                        <h4>${getLabel('Pod')} Details</h4>
                        <p>Based on Image: ${pod.image}</p>
                        <p>Status: ${pod.status}</p>
                        <p>Running on: ${getLabel('Worker Node')} ${clusterState.nodes.find(n => n.id === pod.nodeId)?.name || 'N/A'}</p>
                        <p>${getLabel('Label Selector')}: <code>${labelsStr}</code></p>
                        <h5>Resource Requests</h5>
                        <p>CPU: ${pod.cpuRequest}m | Memory: ${pod.memRequest}Mi</p>
                        <br><button class="danger" onclick="window.sim.killPod(${pod.id})">${getLabel('Kill Pod')}</button>
                    </div>`; 
            }
            function showDeploymentInspector(depId) { 
                const dep = clusterState.deployments[depId]; 
                if (!dep) return; 
                document.getElementById('inspector-title').textContent = `${getLabel('Deployment')}: ${dep.name}`; 
                document.getElementById('inspector-content').innerHTML = `
                    <div class="info-card">
                        <h5>What is this?</h5>
                        <p class="explanation">A <b>${getLabel('Deployment')}</b> manages the ${getLabel('Pod')}s for <b>one component</b> of your application (e.g., the web servers). A complete 'Application' is often composed of multiple ${getLabel('Deployment')}s and ${getLabel('Service')}s working together. <br><br><b>This visual box is a LOGICAL grouping, not a physical one.</b></p>
                    </div>
                    <div class="info-card">
                        <h4>${getLabel('Deployment')} Status</h4>
                        <p>Desired ${getLabel('Replicas')}: ${dep.replicas}</p>
                        <p>Current ${getLabel('Pod')}s: ${Array.from(dep.podIds).filter(id => clusterState.pods[id]).length}</p>
                        <p>${getLabel('Container')} Image: ${dep.image}</p>
                    </div>`; 
            }
            function showServiceInspector(srvId) { 
                const srv = clusterState.services[srvId]; 
                if (!srv) return; 
                document.getElementById('inspector-title').textContent = `${getLabel('Service')}: ${srv.name}`; 
                
                let typeDescription = '';
                if (srv.type === 'ClusterIP' || !srv.type) {
                    typeDescription = 'ClusterIP services are only accessible from within the cluster. They provide a stable internal IP address for pod-to-pod communication.';
                } else if (srv.type === 'NodePort') {
                    typeDescription = `NodePort services expose the service on each node's IP at a static port (${srv.nodePort}). External traffic can access the service by connecting to any node on this port.`;
                } else if (srv.type === 'LoadBalancer') {
                    typeDescription = 'LoadBalancer services provision an external load balancer (in supported cloud environments) that distributes traffic across all nodes. This provides a single external IP for accessing the service.';
                }
                
                document.getElementById('inspector-content').innerHTML = `
                    <div class="info-card">
                        <h5>What is this?</h5>
                        <p class="explanation">A <b>${srv.type || 'ClusterIP'} Service</b> operates in the <b>Network Plane</b> above the cluster. It uses <b>label selectors</b> to find matching pods and provides a stable network endpoint for accessing them.</p>
                        <p class="explanation" style="margin-top: 10px;">${typeDescription}</p>
                    </div>
                    <div class="info-card">
                        <h4>Service Details</h4>
                        <p>Type: <b>${srv.type || 'ClusterIP'}</b></p>
                        ${srv.nodePort ? `<p>NodePort: <b>${srv.nodePort}</b></p>` : ''}
                        <p>Label Selector: ${srv.selector ? Object.entries(srv.selector).map(([k, v]) => `${k}=${v}`).join(', ') : 'None'}</p>
                        <p>Matching Pods: ${Object.values(clusterState.pods).filter(pod => pod.labels && srv.selector && Object.entries(srv.selector).every(([key, value]) => pod.labels[key] === value)).length}</p>
                    </div>
                    <div class="info-card">
                        <h4>Actions</h4>
                        <button onclick="window.sim.simulateTraffic(${srv.id})">Simulate Traffic</button>
                        <button onclick="window.sim.deleteService(${srv.id})" style="background-color: #F44336;">Delete Service</button>
                    </div>`; 
            }
            function hideInspector() { 
                document.getElementById('inspector-title').textContent = 'Inspector';
                document.getElementById('inspector-content').innerHTML = '<p style="color: var(--ui-text-secondary); text-align: center; margin-top: var(--spacing-xl);">Click on any object in the cluster to see its details here.</p>';
            }
            function updateServiceList() { const listEl = document.getElementById('service-list'); listEl.innerHTML = ''; Object.values(clusterState.services).forEach(srv => { const el = document.createElement('div'); el.className = 'info-card'; const selectorStr = srv.selector ? Object.entries(srv.selector).map(([k, v]) => `${k}=${v}`).join(', ') : 'None'; el.innerHTML = `<h4>${srv.name}</h4><p>Selector: ${selectorStr}</p><button onclick="window.sim.simulateTraffic(${srv.id})">Simulate Traffic</button>`; listEl.appendChild(el); }); }
            function updateLabelSelector() {
                const select = document.getElementById('service-label-selector');
                const currentSelections = Array.from(select.selectedOptions).map(opt => opt.value);
                
                // Collect all unique labels from all pods
                const labelSet = new Set();
                Object.values(clusterState.pods).forEach(pod => {
                    if (pod.labels && pod.status !== 'Terminating') {
                        Object.entries(pod.labels).forEach(([key, value]) => {
                            labelSet.add(`${key}=${value}`);
                        });
                    }
                });
                
                // Clear and repopulate the select
                select.innerHTML = '';
                
                if (labelSet.size === 0) {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'No pod labels available';
                    option.disabled = true;
                    select.appendChild(option);
                } else {
                    // Sort labels and add them as options
                    const sortedLabels = Array.from(labelSet).sort();
                    sortedLabels.forEach((label, index) => {
                        const option = document.createElement('option');
                        option.value = label;
                        option.textContent = label;
                        // Restore previous selections
                        if (currentSelections.includes(label)) {
                            option.selected = true;
                        }
                        // If no selections exist, select the first option
                        else if (currentSelections.length === 0 && index === 0) {
                            option.selected = true;
                        }
                        select.appendChild(option);
                    });
                }
            }
            function renderHierarchy() { 
                const treeContainer = document.getElementById('hierarchy-tree'); 
                const scrollTop = treeContainer.scrollTop; 
                treeContainer.innerHTML = ''; 
                
                const clusterUl = document.createElement('ul'); 
                clusterUl.innerHTML = `<li><div class="tree-item"><span class="tree-swivel">‚ñº</span><span><b>Cluster</b></span></div></li>`; 
                const clusterLi = clusterUl.firstElementChild; 
                const resourcesUl = document.createElement('ul'); 
                resourcesUl.className = 'tree-item-children'; 
                
                // Nodes section
                const nodesLi = document.createElement('li'); 
                nodesLi.innerHTML = `<div class="tree-item"><span class="tree-swivel">‚ñº</span><span><b>${getLabel('Nodes')}</b></span></div>`; 
                const nodesUl = document.createElement('ul'); 
                nodesUl.className = 'tree-item-children'; 
                
                clusterState.nodes.forEach(node => { 
                    const nodeLi = document.createElement('li'); 
                    const eyeIcon = node.isVisible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è'; 
                    const nodeType = node.type === 'master' ? getLabel('Master Node') : getLabel('Worker Node');
                    const trashCan = node.type === 'worker' ? '<span class="tree-trash" title="Delete Node">üóëÔ∏è</span>' : '';
                    nodeLi.innerHTML = `<div class="tree-item" data-id="${node.id}" data-type="node"><span class="tree-swivel">${node.pods.size > 0 ? '‚ñ∂' : ''}</span><span class="tree-eye">${eyeIcon}</span><span>${node.name}</span><span class="role">(${nodeType})</span>${trashCan}</div>`; 
                    
                    const podsUl = document.createElement('ul'); 
                    podsUl.className = 'tree-item-children collapsed'; 
                    
                    Array.from(node.pods).map(id => clusterState.pods[id]).filter(Boolean).forEach(pod => { 
                        const podLi = document.createElement('li'); 
                        const podEye = pod.isVisible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è'; 
                        podLi.innerHTML = `<div class="tree-item" data-id="${pod.id}" data-type="pod"><span class="tree-swivel">‚ñº</span><span class="tree-eye">${podEye}</span><span style="color:${CONFIG.APP_COLORS[pod.image]}">${getLabel('Pod')}: ${pod.name}</span><span class="tree-trash" title="Delete Pod">üóëÔ∏è</span></div>`; 
                        
                        const containerUl = document.createElement('ul'); 
                        containerUl.className = 'tree-item-children'; 
                        containerUl.innerHTML = `<li><div class="tree-item"><span class="tree-swivel"></span><span class="tree-eye" style="opacity:0.5"></span><span style="color:${CONFIG.APP_COLORS[pod.image]}">${getLabel('Container')}: ${pod.image}</span></div></li>`; 
                        podLi.appendChild(containerUl); 
                        podsUl.appendChild(podLi); 
                    }); 
                    
                    if (node.pods.size > 0) nodeLi.appendChild(podsUl); 
                    nodesUl.appendChild(nodeLi); 
                }); 
                
                nodesLi.appendChild(nodesUl); 
                resourcesUl.appendChild(nodesLi); 
                
                // Deployments section
                const depsLi = document.createElement('li'); 
                depsLi.innerHTML = `<div class="tree-item"><span class="tree-swivel">‚ñº</span><span><b>${getLabel('Deployments')}</b></span></div>`; 
                const depsUl = document.createElement('ul'); 
                depsUl.className = 'tree-item-children'; 
                
                Object.values(clusterState.deployments).forEach(dep => { 
                    const depLi = document.createElement('li'); 
                    const eyeIcon = dep.isVisible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è'; 
                    depLi.innerHTML = `<div class="tree-item" data-id="${dep.id}" data-type="deployment"><span class="tree-swivel"></span><span class="tree-eye">${eyeIcon}</span><span style="color: ${CONFIG.APP_COLORS[dep.image]}">${dep.name}</span><span class="tree-trash" title="Delete Deployment">üóëÔ∏è</span></div>`; 
                    depsUl.appendChild(depLi); 
                }); 
                
                depsLi.appendChild(depsUl); 
                resourcesUl.appendChild(depsLi); 
                
                // Services section
                const srvsLi = document.createElement('li'); 
                srvsLi.innerHTML = `<div class="tree-item"><span class="tree-swivel">‚ñº</span><span><b>${getLabel('Services')}</b></span></div>`; 
                const srvsUl = document.createElement('ul'); 
                srvsUl.className = 'tree-item-children'; 
                
                Object.values(clusterState.services).forEach(srv => { 
                    const srvLi = document.createElement('li'); 
                    const eyeIcon = srv.isVisible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è'; 
                    const matchingPod = Object.values(clusterState.pods).find(pod => { 
                        if (!pod.labels || !srv.selector) return false; 
                        return Object.entries(srv.selector).every(([key, value]) => pod.labels[key] === value); 
                    }); 
                    const color = matchingPod ? CONFIG.APP_COLORS[matchingPod.image] : '#00BCD4'; 
                    srvLi.innerHTML = `<div class="tree-item" data-id="${srv.id}" data-type="service"><span class="tree-swivel"></span><span class="tree-eye">${eyeIcon}</span><span style="color: ${color}">${srv.name}</span><span class="tree-trash" title="Delete Service">üóëÔ∏è</span></div>`; 
                    srvsUl.appendChild(srvLi); 
                }); 
                
                srvsLi.appendChild(srvsUl); 
                resourcesUl.appendChild(srvsLi); 
                clusterLi.appendChild(resourcesUl); 
                treeContainer.appendChild(clusterUl); 
                treeContainer.scrollTop = scrollTop; 
            }
            function toggleTreeItemVisibility(element, isVisible) {
                const { id, type } = element.dataset; let stateObject; let threeObj; if (type === 'node') stateObject = clusterState.nodes.find(n => n.id == id); if (type === 'pod') stateObject = clusterState.pods[id]; if (type === 'deployment') stateObject = clusterState.deployments[id]; if (type === 'service') stateObject = clusterState.services[id]; if (stateObject) {
                    stateObject.isVisible = isVisible; const eyeElement = element.querySelector('.tree-eye'); if (eyeElement) eyeElement.textContent = isVisible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è'; if (type === 'deployment') threeObj = threeObjects.get(`dep-${id}`); else if (type === 'service') threeObj = threeObjects.get(`srv-${id}`); else threeObj = threeObjects.get(stateObject.id); if (threeObj) {
                        threeObj.visible = isVisible; 
                        threeObj.traverse(child => { 
                            if (child.isCSS2DObject) child.visible = isVisible; 
                        }); 
                        if (type === 'deployment') {
                            // Services are now independent of deployments
                        }
                        if (type === 'node') {
                            const node = stateObject;
                            node.pods.forEach(podId => {
                                const pod = clusterState.pods[podId];
                                if (pod) {
                                    pod.isVisible = isVisible;
                                    const podEye = document.querySelector(`.tree-item[data-id="${pod.id}"]`);
                                    if (podEye) toggleTreeItemVisibility(podEye, isVisible);
                                }
                            });
                        }
                        if (type === 'service') {
                            const srv = stateObject;
                            srv.networkLines.forEach(line => line.visible = isVisible);
                        }
                    }
                }
            }
                            function showAddNodeModal() { const modal = document.getElementById('modal-overlay'); const input = document.getElementById('new-node-name-input'); const workerCount = clusterState.nodes.filter(n => n.type === 'worker').length; input.value = `worker-node-${workerCount + 1}`; modal.style.display = 'flex'; input.focus(); }
                            function hideAddNodeModal() { document.getElementById('modal-overlay').style.display = 'none'; }
                            function setTool(toolName) {
                                currentTool = toolName;
                                document.getElementById('cluster-container').className = `${toolName}-tool`;
                                document.getElementById('select-tool').classList.toggle('active', toolName === 'select');
                                document.getElementById('navigate-tool').classList.toggle('active', toolName === 'navigate');
                                controls.enabled = toolName === 'navigate';
                            }

                            document.getElementById('hierarchy-tree').addEventListener('click', e => { 
                                const item = e.target.closest('.tree-item'); 
                                if (!item) return; 
                                
                                if (e.target.classList.contains('tree-swivel')) { 
                                    const children = item.nextElementSibling; 
                                    if (children) { 
                                        children.classList.toggle('collapsed'); 
                                        e.target.textContent = children.classList.contains('collapsed') ? '‚ñ∂' : '‚ñº'; 
                                    } 
                                } else if (e.target.classList.contains('tree-eye')) { 
                                    const currentVisibility = e.target.textContent === 'üëÅÔ∏è'; 
                                    toggleTreeItemVisibility(item, !currentVisibility); 
                                } else if (e.target.classList.contains('tree-trash')) {
                                    const { id, type } = item.dataset;
                                    let confirmMsg = '';
                                    
                                    if (type === 'node') {
                                        const node = clusterState.nodes.find(n => n.id === id);
                                        if (node && node.type === 'worker') {
                                            confirmMsg = `Delete worker node ${node.name}? All pods on this node will be rescheduled.`;
                                        }
                                    } else if (type === 'pod') {
                                        const pod = clusterState.pods[id];
                                        if (pod) confirmMsg = `Delete pod ${pod.name}?`;
                                    } else if (type === 'deployment') {
                                        const dep = clusterState.deployments[id];
                                        if (dep) confirmMsg = `Delete deployment ${dep.name}? This will also delete all its pods.`;
                                    } else if (type === 'service') {
                                        const srv = clusterState.services[id];
                                        if (srv) confirmMsg = `Delete service ${srv.name}?`;
                                    }
                                    
                                    if (confirmMsg && confirm(confirmMsg)) {
                                        if (type === 'node' && clusterState.nodes.find(n => n.id === id && n.type === 'worker')) {
                                            removeWorkerNode(id);
                                        } else if (type === 'pod') {
                                            terminatePod(id, 'deleted by user');
                                        } else if (type === 'deployment') {
                                            deleteDeployment(id);
                                        } else if (type === 'service') {
                                            deleteService(id);
                                        }
                                    }
                                } else { 
                                    const { id, type } = item.dataset; 
                                    if (type === 'node') showNodeInspector(id); 
                                    if (type === 'pod') showPodInspector(id); 
                                    if (type === 'deployment') showDeploymentInspector(id); 
                                    if (type === 'service') { 
                                        showServiceInspector(id); 
                                        clusterState.selectedServiceId = id; 
                                    } 
                                } 
                            });
                            document.getElementById('hierarchy-search').addEventListener('input', e => { const searchTerm = e.target.value.toLowerCase(); const allItems = document.querySelectorAll('#hierarchy-tree li'); if (!searchTerm) { allItems.forEach(i => i.style.display = ''); return; } allItems.forEach(li => { const item = li.querySelector('.tree-item'); const text = item.textContent.toLowerCase(); const match = text.includes(searchTerm); li.style.display = match ? '' : 'none'; if (match) { let parentLi = li.parentElement.closest('li'); while (parentLi) { parentLi.style.display = ''; parentLi = parentLi.parentElement.closest('li'); } } }); });
                            document.getElementById('deployment-list').addEventListener('click', e => { const item = e.target.closest('.tree-item'); if (!item) return; if (e.target.classList.contains('tree-swivel')) { const children = item.nextElementSibling; if (children) { children.classList.toggle('collapsed'); e.target.textContent = children.classList.contains('collapsed') ? '‚ñ∂' : '‚ñº'; } } else { const { id, type } = item.dataset; if (type === 'pod') showPodInspector(id); if (type === 'deployment') showDeploymentInspector(id); } });

                            initThree();
                            document.getElementById('add-worker-btn').addEventListener('click', showAddNodeModal);
                            document.getElementById('confirm-add-node-btn').addEventListener('click', () => { const name = document.getElementById('new-node-name-input').value; if (name) addNode('worker', name); hideAddNodeModal(); });
                            document.getElementById('cancel-add-node-btn').addEventListener('click', hideAddNodeModal);
                            document.getElementById('new-node-name-input').addEventListener('keydown', e => { if (e.key === 'Enter') document.getElementById('confirm-add-node-btn').click(); });
                            document.getElementById('remove-worker-btn').addEventListener('click', removeLastWorkerNode);
                            document.getElementById('create-deployment-btn').addEventListener('click', createDeployment);
                            document.getElementById('create-service-btn').addEventListener('click', createService);
                            document.getElementById('close-welcome-btn').addEventListener('click', () => {
                                document.getElementById('welcome-panel').style.display = 'none';
                                setCookie('k8sviz_welcome_shown', 'true', 365); // Remember for 1 year
                            });
                            document.getElementById('close-inspector-btn').addEventListener('click', hideInspector);
                            document.getElementById('pause-btn').addEventListener('click', () => { clusterState.isPaused = !clusterState.isPaused; document.getElementById('pause-btn').textContent = clusterState.isPaused ? 'Resume' : 'Pause'; });
                            document.getElementById('replica-slider').addEventListener('input', e => document.getElementById('replica-count-label').textContent = e.target.value);
                            // Remove old toggle button listener as we now have unified panels
                            document.getElementById('select-tool').addEventListener('click', () => setTool('select'));
                            document.getElementById('navigate-tool').addEventListener('click', () => setTool('navigate'));
                            
                            // Ensure navigate mode is set on startup
                            setTool('navigate');
                            
                            document.addEventListener('keydown', e => {
                                if (e.key === 's' || e.key === 'S') setTool('select');
                                if (e.key === 'v' || e.key === 'V') setTool('navigate');
                            });

                            // Panel Resizing
            function initPanelResizing() {
                const leftPanel = document.getElementById('left-panel');
                const rightPanel = document.getElementById('right-panel');
                const bottomPanel = document.getElementById('bottom-panel');
                const leftHandle = leftPanel.querySelector('.panel-resize-handle');
                const rightHandle = rightPanel.querySelector('.panel-resize-handle');
                const bottomHandle = bottomPanel.querySelector('.panel-resize-handle');
                const splitHandle = document.getElementById('right-split');
                
                let currentHandle = null;
                let startX = 0;
                let startY = 0;
                let startWidth = 0;
                let startHeight = 0;
                let startSplit = 0;
                
                function startResize(e, handle, type) {
                    currentHandle = handle;
                    handle.classList.add('dragging');
                    startX = e.clientX;
                    startY = e.clientY;
                    
                    if (type === 'left') {
                        startWidth = leftPanel.offsetWidth;
                    } else if (type === 'right') {
                        startWidth = rightPanel.offsetWidth;
                    } else if (type === 'bottom') {
                        startHeight = bottomPanel.offsetHeight;
                    } else if (type === 'split') {
                        const hierarchySection = document.getElementById('hierarchy-section');
                        startSplit = hierarchySection.offsetHeight;
                    }
                    
                    document.addEventListener('mousemove', doResize);
                    document.addEventListener('mouseup', stopResize);
                    e.preventDefault();
                }
                
                function doResize(e) {
                    if (!currentHandle) return;
                    
                    if (currentHandle === leftHandle) {
                        const newWidth = Math.max(200, Math.min(500, startWidth + e.clientX - startX));
                        document.documentElement.style.setProperty('--left-panel-width', newWidth + 'px');
                        updateLayout();
                    } else if (currentHandle === rightHandle) {
                        const newWidth = Math.max(250, Math.min(600, startWidth - e.clientX + startX));
                        document.documentElement.style.setProperty('--right-panel-width', newWidth + 'px');
                        updateLayout();
                    } else if (currentHandle === bottomHandle) {
                        const newHeight = Math.max(60, Math.min(300, startHeight - e.clientY + startY));
                        document.documentElement.style.setProperty('--bottom-panel-height', newHeight + 'px');
                        updateLayout();
                    } else if (currentHandle === splitHandle) {
                        const containerHeight = rightPanel.offsetHeight;
                        const newHeight = Math.max(100, Math.min(containerHeight - 100, startSplit + e.clientY - startY));
                        const percentage = (newHeight / containerHeight) * 100;
                        document.getElementById('hierarchy-section').style.height = percentage + '%';
                        document.getElementById('inspector-section').style.height = (100 - percentage) + '%';
                    }
                }
                
                function stopResize() {
                    if (currentHandle) {
                        currentHandle.classList.remove('dragging');
                        currentHandle = null;
                    }
                    document.removeEventListener('mousemove', doResize);
                    document.removeEventListener('mouseup', stopResize);
                }
                
                function updateLayout() {
                    // Get current dimensions from CSS variables
                    const leftWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--left-panel-width'));
                    const rightWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--right-panel-width'));
                    const bottomHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bottom-panel-height'));
                    
                    // Update camera aspect ratio
                    if (camera && renderer) {
                        const width = Math.max(1, window.innerWidth - leftWidth - rightWidth);
                        const height = Math.max(1, window.innerHeight - 50 - bottomHeight);
                        
                        camera.aspect = width / height;
                        camera.updateProjectionMatrix();
                        renderer.setSize(width, height);
                        labelRenderer.setSize(width, height);
                    }
                }
                
                leftHandle.addEventListener('mousedown', (e) => startResize(e, leftHandle, 'left'));
                rightHandle.addEventListener('mousedown', (e) => startResize(e, rightHandle, 'right'));
                bottomHandle.addEventListener('mousedown', (e) => startResize(e, bottomHandle, 'bottom'));
                splitHandle.addEventListener('mousedown', (e) => startResize(e, splitHandle, 'split'));
                
                // Initial layout update
                updateLayout();
            }
            
            
            // Tooltip descriptions
            const tooltipDescriptions = {
                'Pod': 'Smallest deployable unit - typically one container, sometimes multiple tightly-coupled containers',
                'Container Instance': 'Usually one container, but can be multiple containers that share storage and network',
                'Deployment': 'Ensures desired number of pod replicas are running',
                'Container Manager': 'Keeps your containers running with the right number of copies',
                'Service': 'Routes network traffic to pods based on label selectors',
                'Traffic Router': 'Directs incoming requests to healthy pods',
                'Control Plane': 'Management components that make cluster decisions',
                'Cluster Brain': 'The decision-making center of your system',
                'Worker Node': 'Server that runs your application workloads',
                'Application Server': 'Computer that hosts your running applications',
                'ClusterIP': 'Service only accessible from within the cluster',
                'Internal Only': 'Can only be reached by other apps in the system',
                'NodePort': 'Service accessible on a specific port on every node',
                'Direct Access': 'External access through specific server ports',
                'LoadBalancer': 'Service accessible via cloud provider load balancer',
                'Managed External': 'Cloud provider handles external traffic distribution'
            };
            
            const tooltips = new Map();
            
            // Toggle label mode
            function toggleLabelMode() {
                useIntuitive = !useIntuitive;
                updateAllLabels();
                updateLabelModeIndicator();
                logEvent(`Switched to ${useIntuitive ? 'intuitive' : 'Kubernetes'} terminology`, 'INFO');
            }
            
            // Update label mode indicator
            function updateLabelModeIndicator() {
                const indicator = document.getElementById('label-mode-text');
                if (indicator) {
                    indicator.textContent = useIntuitive ? 
                        'Common Software Engineering Terminology Mode' : 
                        'Kubernetes Terminology Mode';
                }
            }
            
            // Update all visible labels
            function updateAllLabels() {
                // Update all elements with data-label attribute
                document.querySelectorAll('[data-label]').forEach(el => {
                    const k8sLabel = el.getAttribute('data-label');
                    if (el.tagName === 'LABEL') {
                        // For label elements, update with colon
                        el.textContent = getLabel(k8sLabel) + ':';
                    } else if (k8sLabel === 'service-explanation') {
                        // Special handling for service explanation
                        if (useIntuitive) {
                            el.innerHTML = 'Traffic routers send traffic to container instances with specified tags. Select one or more tags from the dropdown.<br>Hold Ctrl/Cmd to select multiple tags.';
                        } else {
                            el.innerHTML = 'Services use label selectors to find pods. Select one or more labels from the dropdown.<br>Hold Ctrl/Cmd to select multiple labels.';
                        }
                    } else if (k8sLabel === 'replicas-explanation') {
                        // Special handling for replicas explanation
                        if (useIntuitive) {
                            el.innerHTML = 'This tells the Container Manager how many identical <b>Container Instances</b> (copies) to keep running.';
                        } else {
                            el.innerHTML = 'This tells the Deployment how many identical <b>Pods</b> (replicas) to keep running.';
                        }
                    } else {
                        el.textContent = getLabel(k8sLabel);
                    }
                });
                
                // Update specific elements by ID or class
                updatePanelLabels();
                renderHierarchy();
                updateDeploymentList();
                updateServiceList();
                
                // Update Three.js labels
                updateThreeJsLabels();
            }
            
            // Update Three.js labels
            function updateThreeJsLabels() {
                // Update control plane component labels
                clusterState.nodes.forEach(node => {
                    if (node.type === 'master' && node.componentOrbs) {
                        const components = [
                            { key: 'API Server' },
                            { key: 'etcd' },
                            { key: 'Scheduler' },
                            { key: 'Controller Manager' }
                        ];
                        
                        node.componentOrbs.forEach((orb, index) => {
                            if (orb.label && components[index]) {
                                orb.label.element.textContent = getLabel(components[index].key);
                            }
                        });
                    }
                    
                    // Update kube-proxy labels on worker nodes
                    if (node.type === 'worker' && node.kubeProxy && node.kubeProxy.label && node.kubeProxy.label.element) {
                        node.kubeProxy.label.element.textContent = getLabel('kube-proxy');
                    }
                });
                
                // Update plane labels
                ['NETWORK', 'CONTROL', 'DATA'].forEach(planeName => {
                    const planeMesh = threeObjects.get(`plane-${planeName}`);
                    if (planeMesh && planeMesh.label) {
                        planeMesh.label.element.textContent = getLabel(CONFIG.PLANES[planeName].label);
                    }
                });
                
                // Update master node "Control Plane" label
                clusterState.nodes.forEach(node => {
                    if (node.type === 'master') {
                        const nodeMesh = threeObjects.get(node.id);
                        if (nodeMesh && nodeMesh.children) {
                            nodeMesh.children.forEach(child => {
                                if (child.isCSS2DObject && child.element && 
                                    (child.element.textContent.includes('Control Plane') || 
                                     child.element.textContent.includes('Cluster Brain'))) {
                                    child.element.textContent = getLabel('Control Plane');
                                }
                            });
                        }
                    }
                });
                
                // Update external load balancer label
                const externalLb = threeObjects.get('external-lb');
                if (externalLb && externalLb.children) {
                    externalLb.children.forEach(child => {
                        if (child.isCSS2DObject && child.element) {
                            child.element.textContent = getLabel('Load Balancer') + ' (External)';
                        }
                    });
                }
            }
            
            // Create tooltip element
            function createTooltip(text, element) {
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.textContent = text;
                tooltip.style.cssText = `
                    position: absolute;
                    background: rgba(0, 0, 0, 0.9);
                    color: white;
                    padding: 8px 12px;
                    border-radius: 4px;
                    font-size: 13px;
                    pointer-events: none;
                    z-index: 1000;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                    max-width: 250px;
                    line-height: 1.4;
                `;
                
                // Position tooltip
                const rect = element.getBoundingClientRect();
                tooltip.style.left = rect.left + 'px';
                tooltip.style.top = (rect.bottom + 5) + 'px';
                
                document.body.appendChild(tooltip);
                
                // Fade in
                requestAnimationFrame(() => {
                    tooltip.style.opacity = '1';
                });
                
                return tooltip;
            }
            
            // Setup tooltip on hover
            function setupTooltip(element, k8sLabel) {
                let hoverTimer;
                let hideTimer;
                let currentTooltip;
                
                element.addEventListener('mouseenter', () => {
                    clearTimeout(hideTimer);
                    
                    hoverTimer = setTimeout(() => {
                        const description = tooltipDescriptions[k8sLabel] || 
                                          tooltipDescriptions[getLabel(k8sLabel)];
                        if (description && !currentTooltip) {
                            currentTooltip = createTooltip(description, element);
                            tooltips.set(element, currentTooltip);
                        }
                    }, 1000);
                });
                
                element.addEventListener('mouseleave', () => {
                    clearTimeout(hoverTimer);
                    
                    if (currentTooltip) {
                        hideTimer = setTimeout(() => {
                            currentTooltip.style.opacity = '0';
                            setTimeout(() => {
                                if (currentTooltip.parentNode) {
                                    currentTooltip.parentNode.removeChild(currentTooltip);
                                }
                                tooltips.delete(element);
                                currentTooltip = null;
                            }, 500);
                        }, 1000);
                    }
                });
            }
            
            // Update panel labels
            function updatePanelLabels() {
                // Panel headers
                const panelHeaders = {
                    'left-panel h2': 'Cluster Explorer',
                    'resource-pool h3': 'Resource Pool',
                    'hierarchy-container h3': 'Hierarchy',
                    'right-panel-header h2': 'Inspector',
                    'bottom-panel h3': 'Event Log'
                };
                
                Object.entries(panelHeaders).forEach(([selector, k8sLabel]) => {
                    const element = document.querySelector(selector);
                    if (element) {
                        element.textContent = getLabel(k8sLabel);
                        if (!element.hasAttribute('data-label')) {
                            element.setAttribute('data-label', k8sLabel);
                            setupTooltip(element, k8sLabel);
                        }
                    }
                });
                
                // Button labels
                document.querySelectorAll('button').forEach(button => {
                    const k8sText = button.getAttribute('data-label') || button.textContent;
                    if (labelMappings[k8sText]) {
                        if (!button.hasAttribute('data-label')) {
                            button.setAttribute('data-label', k8sText);
                        }
                        button.textContent = getLabel(k8sText);
                    }
                });
                
                // Control group headers
                document.querySelectorAll('.control-group h3').forEach(header => {
                    const text = header.childNodes[0].textContent;
                    if (labelMappings[text]) {
                        header.childNodes[0].textContent = getLabel(text);
                        if (!header.hasAttribute('data-label')) {
                            header.setAttribute('data-label', text);
                            setupTooltip(header, text);
                        }
                    }
                });
                
                // Service type options
                const serviceTypeSelector = document.getElementById('service-type-selector');
                if (serviceTypeSelector) {
                    // Store original values if not already done
                    if (!serviceTypeSelector.dataset.initialized) {
                        Array.from(serviceTypeSelector.options).forEach(option => {
                            option.dataset.k8sText = option.text;
                        });
                        serviceTypeSelector.dataset.initialized = 'true';
                    }
                    
                    // Update options based on mode
                    Array.from(serviceTypeSelector.options).forEach(option => {
                        if (useIntuitive) {
                            const intuitive = {
                                'ClusterIP': 'Internal Only',
                                'NodePort': 'Direct Access', 
                                'LoadBalancer': 'Managed External'
                            };
                            option.text = intuitive[option.value] + ' ' + option.dataset.k8sText.match(/\(.*\)/)[0];
                        } else {
                            option.text = option.dataset.k8sText;
                        }
                    });
                }
            }
            
            // Add Tab key listener
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    toggleLabelMode();
                }
            });
            
            window.sim = { scaleDeployment, failNode, killPod, simulateTraffic, deleteService };
                            addNode('master', 'master-node-1'); addNode('worker', 'worker-node-1');
                            setTool('navigate');
                            updateLabelSelector(); // Initialize the label selector
                            initPanelResizing(); // Initialize panel resizing
                            
                            // Initialize label system
                            setTimeout(() => {
                                updatePanelLabels(); // Setup initial labels and tooltips
                                // Update layout to ensure proper panel alignment
                                if (window.updateLayout) window.updateLayout();
                            }, 100);
                            animate(); setInterval(reconciliationLoop, 1000);
                        });
    </script>
</body>

</html>